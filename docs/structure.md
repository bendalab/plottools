# How to structure your code

Here we provide some best-practice tips on how to structure your code
for figures, such that:

- Others, including your future self, are able to modify your figures.
- Plot appearance can be changed quickly from a central module.
- It makes fun to improve your plots.


## File organization

From our general [guidelines](guide.md) we already get some hints on
how to organize the scripts generating the figures. Let's repeat the
relevant issues:

1. Each figure is generated by a single python script.
2. The basename of the generated figure is the same as the one of the python script generating it.
3. The python script only generates the figure, it does not do any heavy computations.
4. Have a single central python module that defines basic figure appearance.

Let's assume we need three figures that we call `basicdata`,
`methods`, and `coolresult`.  Then for each of the figures we will
have a separate python script (1.)  with the respective name (2.).
That way everybody easily finds the script generating that figure.

In addition, we will have a script defining the appearance of the
figures (4.) that will be imported by all of the scripts generating
the actual figures. Let's call that script `plotstyle.py`. This helps
us to separate content from layout.

We keep the file hierarchy flat and simply have four files in our
working directory:
```  txt
+-- plotstyle.py
+-- basicdata.py
+-- methods.py
+-- coolresult.py
```

The content of the `plotstyle.py` module is discussed below, for now we
assume that it provides a single empty function `plot_style()`:
```py
def plot_style():
  pass
```


## Plotting scripts

So how to write an actual script generating a figure?

Let's start simple with a script `basicdata.py` generating a figure
with just a single panel (subplot).


### Package imports

First of all we need the usual imports of `numpy`, `scipy`, and `pandas` as
required, of `matplotlib.pyplot` and the `plot_style()` function
from our central `plotstyle.py` module:
```py
import numpy as np
import matplotlib.pyplot as plt
from plotstyle import plot_style
```

In contrast to your analysis scripts, try to keep the number of
imported packages as low as possible. This reduces dependencies to a
minimum and makes it easier to reuse the code for generating the
figures. A low number of imports should be no problem, because the
plotting scripts are only plotting and are not supposed to do any
complex data analysis.  The results of complex computation are stored
in files. The plotting scripts just need to read these files and plot
their content - not much overhead is needed.


### Main code

We start out at the bottom of the script with the
following two lines:
```py
if __name__ == "__main__":
   plot_style()
```
The call of the `plot_style()` function sets up the plot
appearance as dicussed below.

The following lines of code should set up the figure, call functions
generating the actual plots, and save the figure to a file. In case of
our simple example this looks like this:
```py
  fig, ax = plt.subplots(figsize=(6, 4))
  fig.subplots_adjust(top=0.95, bottom=0.1, left=0.1, right=0.95)
  plot_data(ax)
  fig.savefig('basicdata.pdf')
```

The call to `plt.subplots()` returns a new figure of the specified
size and a single axes. We exclusively use the object-oriented
interface of matplotlib. That way it is always clear on which axes
plot commands are applied. And matplotlib recommends using the
object-oriented interface anyways (check out the [API
overview](https://matplotlib.org/stable/api/index.html) and [the
lifecycle of a
plot](https://matplotlib.org/stable/tutorials/introductory/lifecycle.html)).
See the [plottools.figure](figure.md#figure-size) module for the `cmsize`
argument, that allows to specifiy the figure size in centimeters
instead of inches.

Most certainly you need to adjust the figure margins via
`fig.subplots_adjust()`. A good plot does not have excessive white
space. In particular if you include your figure in a LaTeX document it
is much simpler to handle when it tightly fills the figure
canvas. `fig.tight_layout()` usually does not work, but you may give a
try to the `constrained_layout` argument to `plt.subplots()`. A
problem with `fig.subplots_adjust()` is, that the figure margins are
specified relative to the figure size. Whenever changing the figure
size you need to readjust the figure margins, which is pretty
annoying. Alternatively you may use the `topm`, `bottomm`, `leftm`,
`rightm` arguments introduced by the
[plottools.subplots](subplots#figure-margins) module, that allow to
specify the margins in units of the font size.

The following function call to `plot_data(ax)` does the actual
plotting. We discuss this in the next section.

Finally, the figure needs to be saved. The filename should be the same
as the name of the script to allow others to find the script given the
figure file. You may omit the file extension if you have set the
rcParam `savefig.format` to your preferred format. In the context of
scientific publications this should be a vector graphic format like
`pdf` or `svg`. Using the
[plottools.figure](figure.md#default-file-name) module allows you to
call `fig.savefig()` without argument. It then automatically saves the
figure under the same as the script.


### Plot code

The basic unit of any figure is a plot, a single matplotlib axes.  You
may rearrange the position of an axes within a figure or even move an
axes to another figure. To allow for this flexibility it is mandatory
to summarize all code needed to draw the content of an axes into a
single dedicated function that takes as the first argument the axes
into which it should draw.

*For every axes make a function that does the plotting and that takes
 this axes as an argument.*

In our example this is the `plot_data()` function, that might look
like this:
```py
def plot_data(ax):
  x, y = load_data()
  ax.plot(x, y)
  ax.set_xlabel('x')
  ax.set_ylabel('y')
```
The first part of the function loads or generates the data to be
plotted - symbolized by the `load_data()` function call.  The second
part does the actual plotting. If you manage to separate content from
design (more on this below), then these functions for the actual
plotting are usually simple and sweet. Everybody can comprehend what
is going on. The function - the plot - can be easily reused in a
different context.

Alternatively we could have called `load_data()` outside the
`plot_data()` function and pass the loaded data as arguments to the
plot function:
```py
  x, y = load_data()
  plot_data(ax, x, y)
```
Then `plot_data()` would only contain plot commands. This is in
particular useful for a multi-panel plot, where many panels use the
same data for their plotting. 

However, in many cases the data are loaded or generated in no time. So
from a performance point of view it does not hurt to load/generate
them for any plot within the plot function. The advantage of
loading/generating the data within the plot function is, that 

- less arguments need to be passed to the plot function, which makes
  the code less cluttered, and
- dependencies of the plot function are reduced, which makes it
  simpler to copy (or import) the plot function to another script and
  use it there.


### Multipanel figures


## Plot style

You may pass a few arguments to `plot_style()`, but try to keep this
simple. In the end, all the generated plots should follow the same
design, so there is no need to pass many arguments to `plot_style()`.

