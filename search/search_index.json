{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"plottools Simplify production of publication-quality figures based on matplotlib . matplotlib is a powerful package for plotting in python . It allows detailed control over every possible aspect of a plot. However, a lot of the provided functionality is cumbersome to use and impossible to remember. For specific use cases, however, a lot of this can be hidden in dedicated functions. The plottools package does this for scientific publications by adding a number of functions to matplotlib and Figure classes. The second design goal of the plottools package is separation of content and design. We know this from LaTeX documents. A good LaTeX document contains only the text and the logical structure. The actual layout (fonts, format of the sections, etc.) can then be entirely controlled by the header without touching the text. Equivalently, python scripts generating various figures should only provide the data and necessary annotation like axes labels. The design should be controllable by a single central function or module that is used by all the scripts generating the figures. matplotlib 's rcParams are a big step in this direction but do not completely reach this goal. The plottools package expands on this, by providing additional rcParams , and by introducing the concept of plot styles . Modules The following modules are provided by the plottools package. See API documentation of the modules for more infos. Enhanced matplotlib functionality Most modules patch the matplotlib and Axes classes to provide new functionality or some specialized interface: align : align axes labels. arrows : arrows. aspect : adapting plots to aspect ratio of axes. axes : setting appearance of axes. circuits : electrical circuits. common : reduce common axis labels. figure : size and file names of a figure . insets : insets made easy. More... labels : annotate axis with label and unit. legend : enhance legend text. neurons : draw sketches of neurons. remove : remove specific artists from an axes. scalebars : labeled scale bars. More... significance : indicating statsitical significance. spines : modify the appearance of spines. More... subplots : enhanced subplots with margins. More... tag : tag axes with a label. text : enhance textual annotations. ticks : setting tick locations and formats. More... title : enhance title text. The patching is done by each module's install_<module>() function. This function is called automatically upon importing the module. While some modules simply add a few new member functions (e.g. insets ) others modify existing functions (e.g. figure ). An uninstall_<module>() function is provided to undo the patching. You usually do not need to care about the install/uninstall functions. Simply import the module of interest and you are all set. Colors and styles These two modules do not patch matplotlib , but provide functions aiding the separation of content and design: colors : color palettes and tools for manipulating colors. More... styles : plotting styles. Helper modules These modules are used internally by other modules of the plottools package: latex : translate LaTeX texts. rcsetup : additional validators for matplotlib.rcsetup . version : version of plottools and other packages. Importing plottools modules Each module can be imported separately. No other functionality of the plottools is then installed or executed. The only exception are the plottools and params modules that import all the other modules. For example, if you are only interested in the functions the ticks module provides, then you can do import matplotlib.pyplot as plt import plottools.ticks # installs set_xticks_delta() (and other functions) on matplotlib Axes class fig, ax = plt.subplots() ax.set_xticks_delta(1.0) For importing all plottools modules, simply import the module plottools : import all plottool modules and install their functions in matplotlib . i.e. import plottools.plottools as pt This also imports all the functions of the modules such they can be used directly in the pt namespace. For example: light_blue = pt.lighter(pt.color_palettes['muted']['blue'], 0.4) A special module is params : functions setting default rcParams settings for all modules. which also imports and installs all other modules via the plottools module. This module provides a few functions (e.g. paper_style() ) that set some default rcParams and add a number of plotting styles to a namespace. These functions can be used like this: from plottools.params import paper_style class s: pass # namespace for plotting styles paper_style(s) # install all plottool functions in matplotlib and populate s with plotting styles fig, ax = plt.subplots(cmsize=(12, 8)) # new subplots() argument `cmsize` ax.plot(x, y, **s.lsB1) # plotting style ax.set_xticks_delta(0.5) # new function for setting spacing of tick marks fig.savefig() # use name of script as name for figure file Usually you will not import the params module, but rahter copy one of its functions and adapt them to your own needs. Setting rcParams Most modules have a <module>_params() function for setting rc parameters to default values. In many cases these functions are just an alternative way to set matplotlib 's rcParams . Many plottools modules define additional rcParams , that also can be set by these functions. The following modules just provide such a function as an alternative interface for setting matplotlib 's rcParams : grid : setting grid appearance. Usually, the <module>_params() have many arguments that by default are set to None . Only the arguments that you provide and differ from None are actually set, the other ones stay untouched. For example: from plottools.text import text_params # set the default font size and family: text_params(font_size=12.0, font_family='sans-serif') # turn on LaTex mode: text_params(latex=True) This is equivalent to import matplotlib as mpl mpl.rcParams['font.size'] = 12 mpl.rcParams['font.family'] = 'sans-serif' mpl.rcParams['text.usetex'] = True Demos For a demonstration of the functionality of all modules run python demos.py For demos of the individual modules in plottools/ , run, for example, python -m src.plottools.spines Howtos A quick introduction to matplotlib : Getting started with matplotlib . A general guidline for preparing figures for your next manuscript or presentation: Figure guidelines . From spaghetti code to a structured code generating a figure: Coding a figure . A suggestion for structuring code that generates plot figures: How to structure your code . Bug reporting The plottools are still in a conceptual phase, interfaces might change without notice and tests on various python and matplotlib versions are not done yet. So getting an error is not unlikely. Providing a pull request that fixes the error or provides new functionality is, of course, most appreciated. You can also open an issue, describing the error. Before doing so, check whether you get the error when you run the demo of the respective module. E.g. python -m src.plottools.figures Mention the outcome in the issue. In any case, run python -m src.plottools.version and paste the output ( python , numpy , pandas , matplotlib and plottools versions) into the issue. Documentation The full documentation is provided on github.io .","title":"Home"},{"location":"#plottools","text":"Simplify production of publication-quality figures based on matplotlib . matplotlib is a powerful package for plotting in python . It allows detailed control over every possible aspect of a plot. However, a lot of the provided functionality is cumbersome to use and impossible to remember. For specific use cases, however, a lot of this can be hidden in dedicated functions. The plottools package does this for scientific publications by adding a number of functions to matplotlib and Figure classes. The second design goal of the plottools package is separation of content and design. We know this from LaTeX documents. A good LaTeX document contains only the text and the logical structure. The actual layout (fonts, format of the sections, etc.) can then be entirely controlled by the header without touching the text. Equivalently, python scripts generating various figures should only provide the data and necessary annotation like axes labels. The design should be controllable by a single central function or module that is used by all the scripts generating the figures. matplotlib 's rcParams are a big step in this direction but do not completely reach this goal. The plottools package expands on this, by providing additional rcParams , and by introducing the concept of plot styles .","title":"plottools"},{"location":"#modules","text":"The following modules are provided by the plottools package. See API documentation of the modules for more infos.","title":"Modules"},{"location":"#enhanced-matplotlib-functionality","text":"Most modules patch the matplotlib and Axes classes to provide new functionality or some specialized interface: align : align axes labels. arrows : arrows. aspect : adapting plots to aspect ratio of axes. axes : setting appearance of axes. circuits : electrical circuits. common : reduce common axis labels. figure : size and file names of a figure . insets : insets made easy. More... labels : annotate axis with label and unit. legend : enhance legend text. neurons : draw sketches of neurons. remove : remove specific artists from an axes. scalebars : labeled scale bars. More... significance : indicating statsitical significance. spines : modify the appearance of spines. More... subplots : enhanced subplots with margins. More... tag : tag axes with a label. text : enhance textual annotations. ticks : setting tick locations and formats. More... title : enhance title text. The patching is done by each module's install_<module>() function. This function is called automatically upon importing the module. While some modules simply add a few new member functions (e.g. insets ) others modify existing functions (e.g. figure ). An uninstall_<module>() function is provided to undo the patching. You usually do not need to care about the install/uninstall functions. Simply import the module of interest and you are all set.","title":"Enhanced matplotlib functionality"},{"location":"#colors-and-styles","text":"These two modules do not patch matplotlib , but provide functions aiding the separation of content and design: colors : color palettes and tools for manipulating colors. More... styles : plotting styles.","title":"Colors and styles"},{"location":"#helper-modules","text":"These modules are used internally by other modules of the plottools package: latex : translate LaTeX texts. rcsetup : additional validators for matplotlib.rcsetup . version : version of plottools and other packages.","title":"Helper modules"},{"location":"#importing-plottools-modules","text":"Each module can be imported separately. No other functionality of the plottools is then installed or executed. The only exception are the plottools and params modules that import all the other modules. For example, if you are only interested in the functions the ticks module provides, then you can do import matplotlib.pyplot as plt import plottools.ticks # installs set_xticks_delta() (and other functions) on matplotlib Axes class fig, ax = plt.subplots() ax.set_xticks_delta(1.0) For importing all plottools modules, simply import the module plottools : import all plottool modules and install their functions in matplotlib . i.e. import plottools.plottools as pt This also imports all the functions of the modules such they can be used directly in the pt namespace. For example: light_blue = pt.lighter(pt.color_palettes['muted']['blue'], 0.4) A special module is params : functions setting default rcParams settings for all modules. which also imports and installs all other modules via the plottools module. This module provides a few functions (e.g. paper_style() ) that set some default rcParams and add a number of plotting styles to a namespace. These functions can be used like this: from plottools.params import paper_style class s: pass # namespace for plotting styles paper_style(s) # install all plottool functions in matplotlib and populate s with plotting styles fig, ax = plt.subplots(cmsize=(12, 8)) # new subplots() argument `cmsize` ax.plot(x, y, **s.lsB1) # plotting style ax.set_xticks_delta(0.5) # new function for setting spacing of tick marks fig.savefig() # use name of script as name for figure file Usually you will not import the params module, but rahter copy one of its functions and adapt them to your own needs.","title":"Importing plottools modules"},{"location":"#setting-rcparams","text":"Most modules have a <module>_params() function for setting rc parameters to default values. In many cases these functions are just an alternative way to set matplotlib 's rcParams . Many plottools modules define additional rcParams , that also can be set by these functions. The following modules just provide such a function as an alternative interface for setting matplotlib 's rcParams : grid : setting grid appearance. Usually, the <module>_params() have many arguments that by default are set to None . Only the arguments that you provide and differ from None are actually set, the other ones stay untouched. For example: from plottools.text import text_params # set the default font size and family: text_params(font_size=12.0, font_family='sans-serif') # turn on LaTex mode: text_params(latex=True) This is equivalent to import matplotlib as mpl mpl.rcParams['font.size'] = 12 mpl.rcParams['font.family'] = 'sans-serif' mpl.rcParams['text.usetex'] = True","title":"Setting rcParams"},{"location":"#demos","text":"For a demonstration of the functionality of all modules run python demos.py For demos of the individual modules in plottools/ , run, for example, python -m src.plottools.spines","title":"Demos"},{"location":"#howtos","text":"A quick introduction to matplotlib : Getting started with matplotlib . A general guidline for preparing figures for your next manuscript or presentation: Figure guidelines . From spaghetti code to a structured code generating a figure: Coding a figure . A suggestion for structuring code that generates plot figures: How to structure your code .","title":"Howtos"},{"location":"#bug-reporting","text":"The plottools are still in a conceptual phase, interfaces might change without notice and tests on various python and matplotlib versions are not done yet. So getting an error is not unlikely. Providing a pull request that fixes the error or provides new functionality is, of course, most appreciated. You can also open an issue, describing the error. Before doing so, check whether you get the error when you run the demo of the respective module. E.g. python -m src.plottools.figures Mention the outcome in the issue. In any case, run python -m src.plottools.version and paste the output ( python , numpy , pandas , matplotlib and plottools versions) into the issue.","title":"Bug reporting"},{"location":"#documentation","text":"The full documentation is provided on github.io .","title":"Documentation"},{"location":"code/","text":"Coding a figure There are many different ways how to organize your code. This is also true for code generating figures. But there are some aspects that require our attention. In particular, if we want to separate design from content. Here we start from some spaghetti code and improve it step-by-step. On the way we develop some techniques that make your figure code better maintainable and modifiable. Quick-and-dirty spaghetti code Let's create a figure with two panels on top of each other, showing two sine waves and two exponential functions. Of course, the two plots should be properly labeled. Quickly hacking this down results in something like this: import numpy as np import matplotlib.pyplot as plt # the figure: fig, (ax1, ax2) = plt.subplots(2, 1, constrained_layout=True) # some data: x = np.linspace(0, 10, 200) y = np.sin(2*np.pi*0.5*x) # first plot: ax1.plot(x, y) ax1.plot(x, 2*y) ax1.set_xlabel('x') ax1.set_ylabel('y') # more data: x = np.linspace(-5, 5, 200) y = np.exp(x) # second plot: ax2.plot(x, y) ax2.plot(x, 2*y) ax2.set_xlabel('x') ax2.set_ylabel('y') # save the figure: fig.savefig('plot.pdf') It produces a figure in the standard design of matplotlib: Customize your plot Well, you do not like the standard appearance of the plots. You want larger fonts, and you would like to change the color and width of the plotted lines. You check the documentation of the matplotlib functions and come up with something like this: import numpy as np import matplotlib.pyplot as plt fig, (ax1, ax2) = plt.subplots(2, 1, constrained_layout=True) # some data: x = np.linspace(0, 10, 200) y = np.sin(2*np.pi*0.5*x) # first plot: ax1.plot(x, y, color='tab:red', lw=2) ax1.plot(x, 2*y, color='tab:orange', lw=2) ax1.set_xlabel('x', fontsize=18) ax1.set_ylabel('y', fontsize=18) # more data: x = np.linspace(-5, 5, 200) y = np.exp(x) # second plot: ax2.plot(x, y, color='tab:red', lw=2) ax2.plot(x, 2*y, color='tab:orange', lw=2) ax2.set_xlabel('x', fontsize=18) ax2.set_ylabel('y', fontsize=18) fig.savefig('plot.pdf') As intended, the resulting figure has larger labels and modified line styles: Modularize your code This manual and direct way in modifying the plot appearance has severe disadvantages: if you want to change the design of your figures, you need to change colors, font sizes, etc. on every line you use them. Imaging you have many scripts for producing ten figures, each with many subplots. You do not want to change the hue of your red color, because this requires to change this color in many places. The classical solution to this problem is to assign all these repetitive plot parameters to variables, and to put your code into functions and pull out these parameters as function parameters: import numpy as np import matplotlib.pyplot as plt def sine_plot(ax, color1, color2, lw, fs): \"\"\"Plots two sine waves with different amplitudes.\"\"\" x = np.linspace(0, 10, 200) y = np.sin(2*np.pi*0.5*x) ax.plot(x, y, color=color1, lw=lw) ax.plot(x, 2*y, color=color2, lw=lw) ax.set_xlabel('x', fontsize=fs) ax.set_ylabel('y', fontsize=fs) def exp_plot(ax, color1, color2, lw, fs): \"\"\"Plots two differently scaled exponential functions.\"\"\" x = np.linspace(-5, 5, 200) y = np.exp(x) ax.plot(x, y, color=color1, lw=lw) ax.plot(x, 2*y, color=color2, lw=lw) ax.set_xlabel('x', fontsize=fs) ax.set_ylabel('y', fontsize=fs) # parameters defining plot appearance: fs = 18 color1 = 'tab:red' color2 = 'tab:orange' lw = 2 # the figure: fig, (ax1, ax2) = plt.subplots(2, 1, constrained_layout=True) sine_plot(ax1, color1, color2, lw, fs) exp_plot(ax2, color1, color2, lw, fs) fig.savefig('plot.pdf') Much better! There are several advantages of this code: each subplot is made by a single function and the second part of the short main code takes care of their arrangement. This way, the subplots can be easily rearranged, or even moved to another figure. the appearance of the plots can be controlled entirely from the initial part of the short main script. No need to change anything within the functions. There is, however, one problem. Usually plots are a bit more complex. Some more lines are plotted, for example, and each would need its own color and line style parameter. So the number of parameters tend to explode. And this then makes the functions cumbersome to use, because in the end one has to follow each parameter into the function to figure out which color or text it will change. This gets even worse in case of nested functions. Use matplotlib's rcParams One solution to this problem is provided by matplotlib's rcParams . They allow you to change basic properties of your plots in a global manner. That way, you do not need to pass these parameters through function parameters. In our example, we set the font size via rcParams before we create the figure: import numpy as np import matplotlib.pyplot as plt # no need to pass font size as a parameter: def sine_plot(ax, color1, color2, lw): x = np.linspace(0, 10, 200) y = np.sin(2*np.pi*0.5*x) ax.plot(x, y, color=color1, lw=lw) ax.plot(x, 2*y, color=color2, lw=lw) ax.set_xlabel('x') ax.set_ylabel('y') def exp_plot(ax, color1, color2, lw): x = np.linspace(-5, 5, 200) y = np.exp(x) ax.plot(x, y, color=color1, lw=lw) ax.plot(x, 2*y, color=color2, lw=lw) ax.set_xlabel('x') ax.set_ylabel('y') # use rcParams to set font size globally: plt.rcParams['font.size'] = 18 plt.rcParams['figure.constrained_layout.use'] = True color1 = 'tab:red' color2 = 'tab:orange' lw = 2 # the figure: fig, (ax1, ax2) = plt.subplots(2, 1) sine_plot(ax1, color1, color2, lw) exp_plot(ax2, color1, color2, lw) fig.savefig('plot.pdf') The rcParams font.size sets the size of all text: There are additional rcParams that allow for a finer control of font sizes. Using rcParams already removes quite some clutter from your plot functions and it also improves the main code, because the parameter lists get shorter. But there are still too many parameters for defining the appearances of the plotted lines (and points, and fill styles, ...). Plotting styles Each line you plot has several attributes that you might want to change. It is not only its color, but also its line width, the line style (solid or dashed), transparency, etc. If you take it serious, then all of these should be passed as parameters to the functions that make the plots. This results in very long parameter lists and requires many lines of code in your main script setting these parameters. This explosion of parameters can be nicely reduced to a single variable for each specific type of line you want to plot. Since these parameters are supplied as keyword arguments to the plot functions, they can be combined into dictionaries. Such dictionaries we call \"plotting styles'. And you can give them functional names. Not ls_red intended as a \"line style for drawing a red line\", but something like ls_small for a \"line style for plotting functions with small amplitudes\", for example. Such functional names turn design into content! import numpy as np import matplotlib.pyplot as plt # pass for each line a line style dictionary: def sine_plot(ax, ls_small, ls_large): x = np.linspace(0, 10, 200) y = np.sin(2*np.pi*0.5*x) ax.plot(x, y, **ls_small) # key-word arguments provided by line style ax.plot(x, 2*y, **ls_large) ax.set_xlabel('x') ax.set_ylabel('y') def exp_plot(ax, ls_small, ls_large): x = np.linspace(-5, 5, 200) y = np.exp(x) ax.plot(x, y, **ls_small) ax.plot(x, 2*y, **ls_large) ax.set_xlabel('x') ax.set_ylabel('y') plt.rcParams['figure.constrained_layout.use'] = True plt.rcParams['font.size'] = 18 # define two line styles: ls_small = dict(color='tab:red', lw=2) ls_large = dict(color='tab:orange', lw=2) # the figure: fig, (ax1, ax2) = plt.subplots(2, 1) sine_plot(ax1, ls_small, ls_large) # just pass line styles to the functions exp_plot(ax2, ls_small, ls_large) fig.savefig('plot.pdf') This way we significantly reduce the number of parameters to the plot function. And we achieved another big step towards the separation of design and content. The plot functions just supply the content. How the plots appear is entirely defined by the initial lines of the main script. We can do better. Namespace for plotting styles The rcParams control plotting in a global way. Similarly, we could summarize all our plotting styles in a namespace that we then provide to the functions creating the plots: import numpy as np import matplotlib.pyplot as plt # just pass a namespace `s` holding some plotting styles: def sine_plot(ax, s): x = np.linspace(0, 10, 200) y = np.sin(2*np.pi*0.5*x) ax.plot(x, y, **s.lsSmall) # use line style from namespace ax.plot(x, 2*y, **s.lsLarge) ax.set_xlabel('x') ax.set_ylabel('y') def exp_plot(ax, s): x = np.linspace(-5, 5, 200) y = np.exp(x) ax.plot(x, y, **s.lsSmall) ax.plot(x, 2*y, **s.lsLarge) ax.set_xlabel('x') ax.set_ylabel('y') plt.rcParams['figure.constrained_layout.use'] = True plt.rcParams['font.size'] = 18 # namespace for plotting styles: class s: pass # define two line styles in the `s` namespace: s.lsSmall = dict(color='tab:red', lw=2) s.lsLarge = dict(color='tab:orange', lw=2) # the figure: fig, (ax1, ax2) = plt.subplots(2, 1) sine_plot(ax1, s) # just pass the namespace to the functions exp_plot(ax2, s) fig.savefig('plot.pdf') Now, we reduced the parameter lists to just two arguments: the axes and the namespace holding the plotting styles. Each plot function just gets this namespace. So it is up to the plot function to select an appropriate plotting style from this namespace. In all the examples before, the plotting styles were defined by the caller of the plot functions. By whatever parameters where passed to the function the design of the plotted lines was set. By just passing the namespace, we give this control back to the plot function. And by using functional names for the plotting styles, the plot functions do not need to make decisions on design. Key is to use functional names for the plotting styles. In this way it can be easily ensured that similar things get plotted in the very same way. You can set a few line styles for stimuli, for example, that were used to probe the function of a neuron (e.g. lsStimA , lsStimB ). And a few other styles, for example, for the resulting responses (e.g. lsRespA , lsRespB ). Central function for controlling the design As a last step we pull out the initial lines of the main script into a function that we place into a separate module. This is our plotstyle.py module, that defines a plot_style() function. This function returns a namespace with various plotting styles and sets rcParams : import matplotlib.pyplot as plt def plot_style(): # namespace for plotting styles: class s: pass s.lsSmall = dict(color='tab:red', lw=2) s.lsLarge = dict(color='tab:orange', lw=2) # global settings: plt.rcParams['figure.constrained_layout.use'] = True plt.rcParams['font.size'] = 18 plt.rcParams['axes.xmargin'] = 0 plt.rcParams['axes.ymargin'] = 0 return s And this is how our script looks like: import numpy as np import matplotlib.pyplot as plt from plotstyle import plot_style # import common plot style def sine_plot(ax, s): x = np.linspace(0, 10, 200) y = np.sin(2*np.pi*0.5*x) ax.plot(x, y, **s.lsSmall) ax.plot(x, 2*y, **s.lsLarge) ax.set_xlabel('x') ax.set_ylabel('y') def exp_plot(ax, s): x = np.linspace(-5, 5, 200) y = np.exp(x) ax.plot(x, y, **s.lsSmall) ax.plot(x, 2*y, **s.lsLarge) ax.set_xlabel('x') ax.set_ylabel('y') s = plot_style() # use common plot style # the figure: fig, (ax1, ax2) = plt.subplots(2, 1) sine_plot(ax1, s) exp_plot(ax2, s) fig.savefig('plot.pdf') A single line of code (the first one of the main script) defines all the global design of your plot. The remaining main script arranges the subplots. And the plot functions provide and plot the data and the content (e.g. axes labels, text, arrows), without setting or influencing the design. The design of all the plots can be easily modified in a single place - the plot style module. Because we added a few more rcParams , the figure looks a little bit different: How to structure your code Continue reading with suggestions on how to structure your code .","title":"Coding a figure"},{"location":"code/#coding-a-figure","text":"There are many different ways how to organize your code. This is also true for code generating figures. But there are some aspects that require our attention. In particular, if we want to separate design from content. Here we start from some spaghetti code and improve it step-by-step. On the way we develop some techniques that make your figure code better maintainable and modifiable.","title":"Coding a figure"},{"location":"code/#quick-and-dirty-spaghetti-code","text":"Let's create a figure with two panels on top of each other, showing two sine waves and two exponential functions. Of course, the two plots should be properly labeled. Quickly hacking this down results in something like this: import numpy as np import matplotlib.pyplot as plt # the figure: fig, (ax1, ax2) = plt.subplots(2, 1, constrained_layout=True) # some data: x = np.linspace(0, 10, 200) y = np.sin(2*np.pi*0.5*x) # first plot: ax1.plot(x, y) ax1.plot(x, 2*y) ax1.set_xlabel('x') ax1.set_ylabel('y') # more data: x = np.linspace(-5, 5, 200) y = np.exp(x) # second plot: ax2.plot(x, y) ax2.plot(x, 2*y) ax2.set_xlabel('x') ax2.set_ylabel('y') # save the figure: fig.savefig('plot.pdf') It produces a figure in the standard design of matplotlib:","title":"Quick-and-dirty spaghetti code"},{"location":"code/#customize-your-plot","text":"Well, you do not like the standard appearance of the plots. You want larger fonts, and you would like to change the color and width of the plotted lines. You check the documentation of the matplotlib functions and come up with something like this: import numpy as np import matplotlib.pyplot as plt fig, (ax1, ax2) = plt.subplots(2, 1, constrained_layout=True) # some data: x = np.linspace(0, 10, 200) y = np.sin(2*np.pi*0.5*x) # first plot: ax1.plot(x, y, color='tab:red', lw=2) ax1.plot(x, 2*y, color='tab:orange', lw=2) ax1.set_xlabel('x', fontsize=18) ax1.set_ylabel('y', fontsize=18) # more data: x = np.linspace(-5, 5, 200) y = np.exp(x) # second plot: ax2.plot(x, y, color='tab:red', lw=2) ax2.plot(x, 2*y, color='tab:orange', lw=2) ax2.set_xlabel('x', fontsize=18) ax2.set_ylabel('y', fontsize=18) fig.savefig('plot.pdf') As intended, the resulting figure has larger labels and modified line styles:","title":"Customize your plot"},{"location":"code/#modularize-your-code","text":"This manual and direct way in modifying the plot appearance has severe disadvantages: if you want to change the design of your figures, you need to change colors, font sizes, etc. on every line you use them. Imaging you have many scripts for producing ten figures, each with many subplots. You do not want to change the hue of your red color, because this requires to change this color in many places. The classical solution to this problem is to assign all these repetitive plot parameters to variables, and to put your code into functions and pull out these parameters as function parameters: import numpy as np import matplotlib.pyplot as plt def sine_plot(ax, color1, color2, lw, fs): \"\"\"Plots two sine waves with different amplitudes.\"\"\" x = np.linspace(0, 10, 200) y = np.sin(2*np.pi*0.5*x) ax.plot(x, y, color=color1, lw=lw) ax.plot(x, 2*y, color=color2, lw=lw) ax.set_xlabel('x', fontsize=fs) ax.set_ylabel('y', fontsize=fs) def exp_plot(ax, color1, color2, lw, fs): \"\"\"Plots two differently scaled exponential functions.\"\"\" x = np.linspace(-5, 5, 200) y = np.exp(x) ax.plot(x, y, color=color1, lw=lw) ax.plot(x, 2*y, color=color2, lw=lw) ax.set_xlabel('x', fontsize=fs) ax.set_ylabel('y', fontsize=fs) # parameters defining plot appearance: fs = 18 color1 = 'tab:red' color2 = 'tab:orange' lw = 2 # the figure: fig, (ax1, ax2) = plt.subplots(2, 1, constrained_layout=True) sine_plot(ax1, color1, color2, lw, fs) exp_plot(ax2, color1, color2, lw, fs) fig.savefig('plot.pdf') Much better! There are several advantages of this code: each subplot is made by a single function and the second part of the short main code takes care of their arrangement. This way, the subplots can be easily rearranged, or even moved to another figure. the appearance of the plots can be controlled entirely from the initial part of the short main script. No need to change anything within the functions. There is, however, one problem. Usually plots are a bit more complex. Some more lines are plotted, for example, and each would need its own color and line style parameter. So the number of parameters tend to explode. And this then makes the functions cumbersome to use, because in the end one has to follow each parameter into the function to figure out which color or text it will change. This gets even worse in case of nested functions.","title":"Modularize your code"},{"location":"code/#use-matplotlibs-rcparams","text":"One solution to this problem is provided by matplotlib's rcParams . They allow you to change basic properties of your plots in a global manner. That way, you do not need to pass these parameters through function parameters. In our example, we set the font size via rcParams before we create the figure: import numpy as np import matplotlib.pyplot as plt # no need to pass font size as a parameter: def sine_plot(ax, color1, color2, lw): x = np.linspace(0, 10, 200) y = np.sin(2*np.pi*0.5*x) ax.plot(x, y, color=color1, lw=lw) ax.plot(x, 2*y, color=color2, lw=lw) ax.set_xlabel('x') ax.set_ylabel('y') def exp_plot(ax, color1, color2, lw): x = np.linspace(-5, 5, 200) y = np.exp(x) ax.plot(x, y, color=color1, lw=lw) ax.plot(x, 2*y, color=color2, lw=lw) ax.set_xlabel('x') ax.set_ylabel('y') # use rcParams to set font size globally: plt.rcParams['font.size'] = 18 plt.rcParams['figure.constrained_layout.use'] = True color1 = 'tab:red' color2 = 'tab:orange' lw = 2 # the figure: fig, (ax1, ax2) = plt.subplots(2, 1) sine_plot(ax1, color1, color2, lw) exp_plot(ax2, color1, color2, lw) fig.savefig('plot.pdf') The rcParams font.size sets the size of all text: There are additional rcParams that allow for a finer control of font sizes. Using rcParams already removes quite some clutter from your plot functions and it also improves the main code, because the parameter lists get shorter. But there are still too many parameters for defining the appearances of the plotted lines (and points, and fill styles, ...).","title":"Use matplotlib's rcParams"},{"location":"code/#plotting-styles","text":"Each line you plot has several attributes that you might want to change. It is not only its color, but also its line width, the line style (solid or dashed), transparency, etc. If you take it serious, then all of these should be passed as parameters to the functions that make the plots. This results in very long parameter lists and requires many lines of code in your main script setting these parameters. This explosion of parameters can be nicely reduced to a single variable for each specific type of line you want to plot. Since these parameters are supplied as keyword arguments to the plot functions, they can be combined into dictionaries. Such dictionaries we call \"plotting styles'. And you can give them functional names. Not ls_red intended as a \"line style for drawing a red line\", but something like ls_small for a \"line style for plotting functions with small amplitudes\", for example. Such functional names turn design into content! import numpy as np import matplotlib.pyplot as plt # pass for each line a line style dictionary: def sine_plot(ax, ls_small, ls_large): x = np.linspace(0, 10, 200) y = np.sin(2*np.pi*0.5*x) ax.plot(x, y, **ls_small) # key-word arguments provided by line style ax.plot(x, 2*y, **ls_large) ax.set_xlabel('x') ax.set_ylabel('y') def exp_plot(ax, ls_small, ls_large): x = np.linspace(-5, 5, 200) y = np.exp(x) ax.plot(x, y, **ls_small) ax.plot(x, 2*y, **ls_large) ax.set_xlabel('x') ax.set_ylabel('y') plt.rcParams['figure.constrained_layout.use'] = True plt.rcParams['font.size'] = 18 # define two line styles: ls_small = dict(color='tab:red', lw=2) ls_large = dict(color='tab:orange', lw=2) # the figure: fig, (ax1, ax2) = plt.subplots(2, 1) sine_plot(ax1, ls_small, ls_large) # just pass line styles to the functions exp_plot(ax2, ls_small, ls_large) fig.savefig('plot.pdf') This way we significantly reduce the number of parameters to the plot function. And we achieved another big step towards the separation of design and content. The plot functions just supply the content. How the plots appear is entirely defined by the initial lines of the main script. We can do better.","title":"Plotting styles"},{"location":"code/#namespace-for-plotting-styles","text":"The rcParams control plotting in a global way. Similarly, we could summarize all our plotting styles in a namespace that we then provide to the functions creating the plots: import numpy as np import matplotlib.pyplot as plt # just pass a namespace `s` holding some plotting styles: def sine_plot(ax, s): x = np.linspace(0, 10, 200) y = np.sin(2*np.pi*0.5*x) ax.plot(x, y, **s.lsSmall) # use line style from namespace ax.plot(x, 2*y, **s.lsLarge) ax.set_xlabel('x') ax.set_ylabel('y') def exp_plot(ax, s): x = np.linspace(-5, 5, 200) y = np.exp(x) ax.plot(x, y, **s.lsSmall) ax.plot(x, 2*y, **s.lsLarge) ax.set_xlabel('x') ax.set_ylabel('y') plt.rcParams['figure.constrained_layout.use'] = True plt.rcParams['font.size'] = 18 # namespace for plotting styles: class s: pass # define two line styles in the `s` namespace: s.lsSmall = dict(color='tab:red', lw=2) s.lsLarge = dict(color='tab:orange', lw=2) # the figure: fig, (ax1, ax2) = plt.subplots(2, 1) sine_plot(ax1, s) # just pass the namespace to the functions exp_plot(ax2, s) fig.savefig('plot.pdf') Now, we reduced the parameter lists to just two arguments: the axes and the namespace holding the plotting styles. Each plot function just gets this namespace. So it is up to the plot function to select an appropriate plotting style from this namespace. In all the examples before, the plotting styles were defined by the caller of the plot functions. By whatever parameters where passed to the function the design of the plotted lines was set. By just passing the namespace, we give this control back to the plot function. And by using functional names for the plotting styles, the plot functions do not need to make decisions on design. Key is to use functional names for the plotting styles. In this way it can be easily ensured that similar things get plotted in the very same way. You can set a few line styles for stimuli, for example, that were used to probe the function of a neuron (e.g. lsStimA , lsStimB ). And a few other styles, for example, for the resulting responses (e.g. lsRespA , lsRespB ).","title":"Namespace for plotting styles"},{"location":"code/#central-function-for-controlling-the-design","text":"As a last step we pull out the initial lines of the main script into a function that we place into a separate module. This is our plotstyle.py module, that defines a plot_style() function. This function returns a namespace with various plotting styles and sets rcParams : import matplotlib.pyplot as plt def plot_style(): # namespace for plotting styles: class s: pass s.lsSmall = dict(color='tab:red', lw=2) s.lsLarge = dict(color='tab:orange', lw=2) # global settings: plt.rcParams['figure.constrained_layout.use'] = True plt.rcParams['font.size'] = 18 plt.rcParams['axes.xmargin'] = 0 plt.rcParams['axes.ymargin'] = 0 return s And this is how our script looks like: import numpy as np import matplotlib.pyplot as plt from plotstyle import plot_style # import common plot style def sine_plot(ax, s): x = np.linspace(0, 10, 200) y = np.sin(2*np.pi*0.5*x) ax.plot(x, y, **s.lsSmall) ax.plot(x, 2*y, **s.lsLarge) ax.set_xlabel('x') ax.set_ylabel('y') def exp_plot(ax, s): x = np.linspace(-5, 5, 200) y = np.exp(x) ax.plot(x, y, **s.lsSmall) ax.plot(x, 2*y, **s.lsLarge) ax.set_xlabel('x') ax.set_ylabel('y') s = plot_style() # use common plot style # the figure: fig, (ax1, ax2) = plt.subplots(2, 1) sine_plot(ax1, s) exp_plot(ax2, s) fig.savefig('plot.pdf') A single line of code (the first one of the main script) defines all the global design of your plot. The remaining main script arranges the subplots. And the plot functions provide and plot the data and the content (e.g. axes labels, text, arrows), without setting or influencing the design. The design of all the plots can be easily modified in a single place - the plot style module. Because we added a few more rcParams , the figure looks a little bit different:","title":"Central function for controlling the design"},{"location":"code/#how-to-structure-your-code","text":"Continue reading with suggestions on how to structure your code .","title":"How to structure your code"},{"location":"colors/","text":"Colors module Make sure you know about matplotlib color maps Palettable : many beautiful color palettes Load the color module: import plottools.colors as c Color palettes The color module provides a few color palettes as dictionaries that reference colors by standard color names. c.color_palettes is a dictionary referencing all color palettes provided by the module by their name. For example colors = c.color_palettes['muted'] colors['red'] returns the red color of the colors_muted palette. The returned colors are valid matplotlib colors and can be passed on to the color , facecolor , edgecolor , etc. arguments of the various matplotlib plotting functions. The following sections display the colors and their names of all provided palettes. Plain RGB colors c.colors_plain This palette is provided for completeness. The colors are made up of either full or half saturated RGB values, e.g. red is '#ff0000', green is '#00ff00', and orange is '#ff8000'. Muted colors c.colors_muted This palette extends the colors_henninger palette. Vivid colors c.colors_vivid Vivid but not plain basic colors for a fresh look. Tableau c.colors_tableau This is matplotlib's tableau palette, the default in newer matplotlib versions, also known as tab10 . Color palette by J\u00f6rg Henninger c.colors_henninger Color pallete of our Scientific Computing script c.colors_scicomp Nice red, orange and yellow, but blue and green need some improvement. Color palette of the corporate design of the University of T\u00fcbingen c.colors_unituebingen Farbkreis by Johannes Itten, 1961 c.colors_itten Solarized colors by Ethan Schoonover (from LaTeX xcolor-solarized package) c.colors_solarized Google's material color palette (from LaTeX xcolor-material package) c.colors_material Color manipulation Lighter colors Make colors lighter. For 40% lightness of blue do colors = c.color_palettes['muted'] lightblue = c.lighter(colors['blue'], 0.4) Darker colors Make colors darker. For 40% darker blue do colors = c.color_palettes['muted'] darkblue = c.darker(colors['blue'], 0.4) Gradient between two colors Mix two colors. For 30% transition between blue and orange do colors = c.color_palettes['muted'] colors = c.color_palettes['muted'] color = c.gradient(colors['blue'], colors['orange'], 0.3) LaTeX colors If you want to use in your LaTeX document the same colors as in your plots, then you can export matplotlib colors using the latex_colors() function. Either for single colors: colors = c.color_palettes['muted'] c.latex_colors(colors['red'], 'red') writes to the console \\definecolor{red}{rgb}{0.753,0.153,0.090} or for a whole palette: c.latex_colors(c.color_palettes['vivid']) writes to the console \\definecolor{red}{rgb}{0.843,0.063,0.000} \\definecolor{orange}{rgb}{1.000,0.565,0.000} \\definecolor{yellow}{rgb}{1.000,0.969,0.000} ... Then copy the color definitions into you LaTeX preamble. Do not forget to load the color or xcolor packages before: \\usepackage{xcolor} You then can use the newly defined colors with the usual commands, like for example: \\textcolor{red}{Some text in my special red.} Color maps Generate and register a color map from colors like this: colors = c.color_palettes['muted'] cmcolors = [colors['red'], c.lighter(colors['orange'], 0.85), c.lighter(colors['yellow'], 0.2), c.lighter(colors['lightblue'], 0.8), colors['blue']] cmvalues = [0.0, 0.25, 0.5, 0.8, 1.0] c.colormap('RYB', cmcolors, cmvalues) This is just a simple wrapper for matplotlib.colors.LinearSegmentedColormap and matplotlib.cm import register_cmap . The new colormap can then be used directly by its name for the cmap arguments of imshow() , pcolormesh() , contourf() , etc.: ax.imshow(image, cmap='RYB') Retrieve a single color from a color map: jet_red = c.cmap_color('jet', 0.0) Display colors For displaying colors and color maps, four functions are provided: plot_colors() : plot all colors of a palette and optionally some lighter and darker variants. plot_complementary_colors() : plot complementary colors of a palette on top of each other. plot_color_comparison() : plot matching colors of severals palettes on top of each other. plot_colormap() : plot a color map and its luminance. These functions are helpfull when creating new palettes. See their documentation for details on how to use them.","title":"Colors"},{"location":"colors/#colors-module","text":"Make sure you know about matplotlib color maps Palettable : many beautiful color palettes Load the color module: import plottools.colors as c","title":"Colors module"},{"location":"colors/#color-palettes","text":"The color module provides a few color palettes as dictionaries that reference colors by standard color names. c.color_palettes is a dictionary referencing all color palettes provided by the module by their name. For example colors = c.color_palettes['muted'] colors['red'] returns the red color of the colors_muted palette. The returned colors are valid matplotlib colors and can be passed on to the color , facecolor , edgecolor , etc. arguments of the various matplotlib plotting functions. The following sections display the colors and their names of all provided palettes.","title":"Color palettes"},{"location":"colors/#plain-rgb-colors","text":"c.colors_plain This palette is provided for completeness. The colors are made up of either full or half saturated RGB values, e.g. red is '#ff0000', green is '#00ff00', and orange is '#ff8000'.","title":"Plain RGB colors"},{"location":"colors/#muted-colors","text":"c.colors_muted This palette extends the colors_henninger palette.","title":"Muted colors"},{"location":"colors/#vivid-colors","text":"c.colors_vivid Vivid but not plain basic colors for a fresh look.","title":"Vivid colors"},{"location":"colors/#tableau","text":"c.colors_tableau This is matplotlib's tableau palette, the default in newer matplotlib versions, also known as tab10 .","title":"Tableau"},{"location":"colors/#color-palette-by-jorg-henninger","text":"c.colors_henninger","title":"Color palette by J&ouml;rg Henninger"},{"location":"colors/#color-pallete-of-our-scientific-computing-script","text":"c.colors_scicomp Nice red, orange and yellow, but blue and green need some improvement.","title":"Color pallete of our Scientific Computing script"},{"location":"colors/#color-palette-of-the-corporate-design-of-the-university-of-tubingen","text":"c.colors_unituebingen","title":"Color palette of the corporate design of the University of T&uuml;bingen"},{"location":"colors/#farbkreis-by-johannes-itten-1961","text":"c.colors_itten","title":"Farbkreis by Johannes Itten, 1961"},{"location":"colors/#solarized-colors-by-ethan-schoonover-from-latex-xcolor-solarized-package","text":"c.colors_solarized","title":"Solarized colors by Ethan Schoonover (from LaTeX xcolor-solarized package)"},{"location":"colors/#googles-material-color-palette-from-latex-xcolor-material-package","text":"c.colors_material","title":"Google's material color palette (from LaTeX xcolor-material package)"},{"location":"colors/#color-manipulation","text":"","title":"Color manipulation"},{"location":"colors/#lighter-colors","text":"Make colors lighter. For 40% lightness of blue do colors = c.color_palettes['muted'] lightblue = c.lighter(colors['blue'], 0.4)","title":"Lighter colors"},{"location":"colors/#darker-colors","text":"Make colors darker. For 40% darker blue do colors = c.color_palettes['muted'] darkblue = c.darker(colors['blue'], 0.4)","title":"Darker colors"},{"location":"colors/#gradient-between-two-colors","text":"Mix two colors. For 30% transition between blue and orange do colors = c.color_palettes['muted'] colors = c.color_palettes['muted'] color = c.gradient(colors['blue'], colors['orange'], 0.3)","title":"Gradient between two colors"},{"location":"colors/#latex-colors","text":"If you want to use in your LaTeX document the same colors as in your plots, then you can export matplotlib colors using the latex_colors() function. Either for single colors: colors = c.color_palettes['muted'] c.latex_colors(colors['red'], 'red') writes to the console \\definecolor{red}{rgb}{0.753,0.153,0.090} or for a whole palette: c.latex_colors(c.color_palettes['vivid']) writes to the console \\definecolor{red}{rgb}{0.843,0.063,0.000} \\definecolor{orange}{rgb}{1.000,0.565,0.000} \\definecolor{yellow}{rgb}{1.000,0.969,0.000} ... Then copy the color definitions into you LaTeX preamble. Do not forget to load the color or xcolor packages before: \\usepackage{xcolor} You then can use the newly defined colors with the usual commands, like for example: \\textcolor{red}{Some text in my special red.}","title":"LaTeX colors"},{"location":"colors/#color-maps","text":"Generate and register a color map from colors like this: colors = c.color_palettes['muted'] cmcolors = [colors['red'], c.lighter(colors['orange'], 0.85), c.lighter(colors['yellow'], 0.2), c.lighter(colors['lightblue'], 0.8), colors['blue']] cmvalues = [0.0, 0.25, 0.5, 0.8, 1.0] c.colormap('RYB', cmcolors, cmvalues) This is just a simple wrapper for matplotlib.colors.LinearSegmentedColormap and matplotlib.cm import register_cmap . The new colormap can then be used directly by its name for the cmap arguments of imshow() , pcolormesh() , contourf() , etc.: ax.imshow(image, cmap='RYB') Retrieve a single color from a color map: jet_red = c.cmap_color('jet', 0.0)","title":"Color maps"},{"location":"colors/#display-colors","text":"For displaying colors and color maps, four functions are provided: plot_colors() : plot all colors of a palette and optionally some lighter and darker variants. plot_complementary_colors() : plot complementary colors of a palette on top of each other. plot_color_comparison() : plot matching colors of severals palettes on top of each other. plot_colormap() : plot a color map and its luminance. These functions are helpfull when creating new palettes. See their documentation for details on how to use them.","title":"Display colors"},{"location":"figure/","text":"Figure module Size and file names of a figure. Importing the figure module modifies the matplotlib functions plt.figure() , plt.subplots() , fig.savefig() , and plt.savefig() . import matplotlib.pyplot as plt import plottools.figure Then the following features are available: Figure size The figure size can be specified in centimeters instead of inches via the cmsize argument to plt.figure() and plt.subplots() . Like this: fig = plt.figure(cmsize=(12, 8)) # in centimeters or fig, axs = plt.subplots(3, 2, cmsize=(12, 8)) # in centimeters A set_size_cm() function is also provided: fig = plt.figure() fig.set_size_cm(12, 8) # in centimeters Default file name It is good practice to have a python script save a figure under the same name as the script (see our plotting guidline ). That way it is easy to figure out, which script generated that figure, whithout the need to use cool command line tools like grep . To simplify this, the figure module patches the fig.savefig() function to use the name of the script as the name of the outpt file, when called without argument. If you have a python script myplot.py producing a figure and saving it like this: fig, axs = plt.subplots(2, 3) # some fancy plots ... fig.savefig() The plot is saved in a file named myplot.pdf . When only providing a path, the name of the script is appended: fig.savefig('../') # -> ../myplot.pdf A string to be added to the name of the script is indicated by a initial '+': fig.savefig('+-example') # -> myplot-example.pdf When saving a figure multiple times (for example when needed for a LaTeX beamer talk), then you may want to use the '@' character in the file name. This character in the file name is replaced by 'A', 'B', 'C', ... according to how often fig.savefig() is called from within the same figure. If the '@' is the first character of the file name, it is added to the name of the main script. So in 'example.py' we can write fig.savefig('@') fig.savefig('@') latex_include_figures() This prints to the console \\includegraphics<1>{myplotA} \\includegraphics<2>{myplotB} and generates the respective files. Strip fonts from a pdf figure When using full LaTeX based typesetting in your figures, the resulting files are quite large, because the LaTeX fonts are stored in the files. When you then include these files in a LaTeX document, then the resulting document can be really large, because for each included figure the fonts are stored again and again in the pdf of the document. The best solution I figured out to remove the excessive font descriptions is to run the pdfs of the figures through the ps2ps shell command (from Ghostscript). Then the standalone figure file may look not that nice, but included into the LaTeX docuement it looks the same as before and the resulting pdf is much smaller. To simplify this post-processing step the figure module adds a stripfont argument to fig.savefig() . When set True , then after the figure has been saved to a pdf file it is run through ps2ps in order to remove the fonts. fig.savefig(stripfonts=True)","title":"Figure"},{"location":"figure/#figure-module","text":"Size and file names of a figure. Importing the figure module modifies the matplotlib functions plt.figure() , plt.subplots() , fig.savefig() , and plt.savefig() . import matplotlib.pyplot as plt import plottools.figure Then the following features are available:","title":"Figure module"},{"location":"figure/#figure-size","text":"The figure size can be specified in centimeters instead of inches via the cmsize argument to plt.figure() and plt.subplots() . Like this: fig = plt.figure(cmsize=(12, 8)) # in centimeters or fig, axs = plt.subplots(3, 2, cmsize=(12, 8)) # in centimeters A set_size_cm() function is also provided: fig = plt.figure() fig.set_size_cm(12, 8) # in centimeters","title":"Figure size"},{"location":"figure/#default-file-name","text":"It is good practice to have a python script save a figure under the same name as the script (see our plotting guidline ). That way it is easy to figure out, which script generated that figure, whithout the need to use cool command line tools like grep . To simplify this, the figure module patches the fig.savefig() function to use the name of the script as the name of the outpt file, when called without argument. If you have a python script myplot.py producing a figure and saving it like this: fig, axs = plt.subplots(2, 3) # some fancy plots ... fig.savefig() The plot is saved in a file named myplot.pdf . When only providing a path, the name of the script is appended: fig.savefig('../') # -> ../myplot.pdf A string to be added to the name of the script is indicated by a initial '+': fig.savefig('+-example') # -> myplot-example.pdf When saving a figure multiple times (for example when needed for a LaTeX beamer talk), then you may want to use the '@' character in the file name. This character in the file name is replaced by 'A', 'B', 'C', ... according to how often fig.savefig() is called from within the same figure. If the '@' is the first character of the file name, it is added to the name of the main script. So in 'example.py' we can write fig.savefig('@') fig.savefig('@') latex_include_figures() This prints to the console \\includegraphics<1>{myplotA} \\includegraphics<2>{myplotB} and generates the respective files.","title":"Default file name"},{"location":"figure/#strip-fonts-from-a-pdf-figure","text":"When using full LaTeX based typesetting in your figures, the resulting files are quite large, because the LaTeX fonts are stored in the files. When you then include these files in a LaTeX document, then the resulting document can be really large, because for each included figure the fonts are stored again and again in the pdf of the document. The best solution I figured out to remove the excessive font descriptions is to run the pdfs of the figures through the ps2ps shell command (from Ghostscript). Then the standalone figure file may look not that nice, but included into the LaTeX docuement it looks the same as before and the resulting pdf is much smaller. To simplify this post-processing step the figure module adds a stripfont argument to fig.savefig() . When set True , then after the figure has been saved to a pdf file it is run through ps2ps in order to remove the fonts. fig.savefig(stripfonts=True)","title":"Strip fonts from a pdf figure"},{"location":"guide/","text":"Figure guidelines Based on our year-long experience in preparing scientific publications we suggest the following guidlines for preparing figures: Each figure is generated by a single python script. The basename of the generated figure is the same as the one of the python script generating it. The python script only generates the figure, it does not do any heavy computations. Have a single central python module that defines basic figure appearance. The data needed for plotting are available as .csv tables or other common file formats. Do not use pickles ( .pkl ) for storing data. No manual postprocessing by whatever graphics software. Note, this does not apply for the figures you make for visualization during your actual analysis and method development. The guidelines are only ment for the final figures that go into a manuscript or a presentation. Why? There are a number of good reasons for these rules. Primary reason: figures always change . As long as you work on a manuscript you will always, or your supervisor wants you to, or journal regulations require you to modify your figure. Modifying a figure is a hassle if it takes some effort to find the spot where to edit the script, running the script takes a lot of time because data are computed, manual postprocessing is required. Having small scripts (1.) that are simple to find (2.) and run quickly (3.) without any manual postprocessing (6.) significantly lowers the effort to actually modify a figure. If you decide to change, for example, the fontsize or the colors in all your figures, then it is really annoying and time consuming to go through all your scripts and adapt these settings in every file. If instead a single module takes care about these general issues (4.), they can be modified in no time. rcParams in matplotlib belong there. See coding a figure for more about the separation of content and design. Second reason: figures want to be used . Ideally, the figures you generate are not only used for that particular manuscript you are currently writing. You yourself, your college, your supervisor, or a collaborator might want to use your figures in a different context, like a poster, a talk, or another manuscript, a review paper, or a book chapter. Chances for your figure to be used are dramatically increased, if the figure can be easily modified. For this it is not sufficient to provide the pdf (or even worse, a pixel file like png or even jpg) of the figure. Rather, a simple dedicated script (1.) with all necessary data (3.) that are readable even ten years later (5.) producing the complete figure (6.) ensures that the figure can be easily adapted to another context as needed. Third reason: you need to provide the data of the figures anyways . Many journals nowadays require you to upload the data that were used to generate the figures. Not the raw data, but the ones displayed in the figure. So you need to store this data in files using formats that can be read by others on whatever platform (5.). Storing the processed data into files for direct plotting has the additional advantage that it reduces the dependencies of the code on external packages needed for the computations. This also makes your figure code more likely to be work later on. How to code a figure Continue reading on coding a figure .","title":"Plotting guidelines"},{"location":"guide/#figure-guidelines","text":"Based on our year-long experience in preparing scientific publications we suggest the following guidlines for preparing figures: Each figure is generated by a single python script. The basename of the generated figure is the same as the one of the python script generating it. The python script only generates the figure, it does not do any heavy computations. Have a single central python module that defines basic figure appearance. The data needed for plotting are available as .csv tables or other common file formats. Do not use pickles ( .pkl ) for storing data. No manual postprocessing by whatever graphics software. Note, this does not apply for the figures you make for visualization during your actual analysis and method development. The guidelines are only ment for the final figures that go into a manuscript or a presentation.","title":"Figure guidelines"},{"location":"guide/#why","text":"There are a number of good reasons for these rules.","title":"Why?"},{"location":"guide/#primary-reason-figures-always-change","text":"As long as you work on a manuscript you will always, or your supervisor wants you to, or journal regulations require you to modify your figure. Modifying a figure is a hassle if it takes some effort to find the spot where to edit the script, running the script takes a lot of time because data are computed, manual postprocessing is required. Having small scripts (1.) that are simple to find (2.) and run quickly (3.) without any manual postprocessing (6.) significantly lowers the effort to actually modify a figure. If you decide to change, for example, the fontsize or the colors in all your figures, then it is really annoying and time consuming to go through all your scripts and adapt these settings in every file. If instead a single module takes care about these general issues (4.), they can be modified in no time. rcParams in matplotlib belong there. See coding a figure for more about the separation of content and design.","title":"Primary reason: figures always change."},{"location":"guide/#second-reason-figures-want-to-be-used","text":"Ideally, the figures you generate are not only used for that particular manuscript you are currently writing. You yourself, your college, your supervisor, or a collaborator might want to use your figures in a different context, like a poster, a talk, or another manuscript, a review paper, or a book chapter. Chances for your figure to be used are dramatically increased, if the figure can be easily modified. For this it is not sufficient to provide the pdf (or even worse, a pixel file like png or even jpg) of the figure. Rather, a simple dedicated script (1.) with all necessary data (3.) that are readable even ten years later (5.) producing the complete figure (6.) ensures that the figure can be easily adapted to another context as needed.","title":"Second reason: figures want to be used."},{"location":"guide/#third-reason-you-need-to-provide-the-data-of-the-figures-anyways","text":"Many journals nowadays require you to upload the data that were used to generate the figures. Not the raw data, but the ones displayed in the figure. So you need to store this data in files using formats that can be read by others on whatever platform (5.). Storing the processed data into files for direct plotting has the additional advantage that it reduces the dependencies of the code on external packages needed for the computations. This also makes your figure code more likely to be work later on.","title":"Third reason: you need to provide the data of the figures anyways."},{"location":"guide/#how-to-code-a-figure","text":"Continue reading on coding a figure .","title":"How to code a figure"},{"location":"insets/","text":"Insets module Construct new axes to be used as inset plots. import numpy as np import matplotlib.pyplot as plt import plottools.insets fig, ax = plt.subplots() x = np.arange(-2.0, 5.0, 0.01) y = np.sin(2.0*np.pi*4.0*x) ax.plot(x, y) ax.set_xlim(-2.0, 5.0) ax.set_xlabel('Time [ms]') ax.set_ylim(-1.5, 4.5) ax.set_ylabel('Voltage [mV]') Inset inset() creates new axes at the specified relative axes coordinates (x0, y0, x1, y1). axi = ax.inset((0.2, 0.6, 0.9, 0.95)) x = np.linspace(0, 1, 50) axi.plot(x, x**2, 'r') Zoomed inset zoomed_inset() creates new axes at the specified relative axes coordinates (first argument: x0, y0, x1, y1), draws a box around the original data (second argument, in data coordinates: x0, y0, x1, y1) and sets the limits of the inset axes accordingly. The third argument specifies lines to be drawn from the data box to the inset. Each tuple specifies a corner on the data box that is to be connected with another corner of the inset. axi = ax.zoomed_inset([0.2, 0.6, 0.9, 0.95], [0.0, -1.1, 2.0, 1.1], [(4, 1), (3, 2)], lw=0.5) axi.plot(x, y)","title":"Insets"},{"location":"insets/#insets-module","text":"Construct new axes to be used as inset plots. import numpy as np import matplotlib.pyplot as plt import plottools.insets fig, ax = plt.subplots() x = np.arange(-2.0, 5.0, 0.01) y = np.sin(2.0*np.pi*4.0*x) ax.plot(x, y) ax.set_xlim(-2.0, 5.0) ax.set_xlabel('Time [ms]') ax.set_ylim(-1.5, 4.5) ax.set_ylabel('Voltage [mV]')","title":"Insets module"},{"location":"insets/#inset","text":"inset() creates new axes at the specified relative axes coordinates (x0, y0, x1, y1). axi = ax.inset((0.2, 0.6, 0.9, 0.95)) x = np.linspace(0, 1, 50) axi.plot(x, x**2, 'r')","title":"Inset"},{"location":"insets/#zoomed-inset","text":"zoomed_inset() creates new axes at the specified relative axes coordinates (first argument: x0, y0, x1, y1), draws a box around the original data (second argument, in data coordinates: x0, y0, x1, y1) and sets the limits of the inset axes accordingly. The third argument specifies lines to be drawn from the data box to the inset. Each tuple specifies a corner on the data box that is to be connected with another corner of the inset. axi = ax.zoomed_inset([0.2, 0.6, 0.9, 0.95], [0.0, -1.1, 2.0, 1.1], [(4, 1), (3, 2)], lw=0.5) axi.plot(x, y)","title":"Zoomed inset"},{"location":"scalebars/","text":"Scalebars module Scalebars are an alternative to xticks and yticks. They visualize scales by the length of a bar. ax.scalebars(1.05, 0.0, 2, 1, 's', 'mV', ha='right', va='bottom') Do not use scalebars if a specific value on the axis (most likely zero) has a special meaning! The scalebar module installs the three functions xscalebar() yscalebar() scalebars() on matplotlib axes for drawing and annotating horizontal or vertical scalebars, or both. import matplotlib.pyplot as plt from plottools.scalebars import scalebar_params fig, ax = plt.subplots() X Scalebars xscalebar() draws and annotates a horizontal scalebar, visualizing the scale of the x-axis. ax.xscalebar(1.0, 0.0, 2, 's', ha='right', va='bottom') The first two arguments of the scalebar functions set the anchor point on which the scalebar is positioned. The scalebar position is given in relative coordinates of the axes (ranging from 0 to 1). For horizontal scalebars, ha (horizontal alignment) determines whether the anchor is on the 'left', 'center', or 'right' of the scalebar. The vertical alignment ( va ) determines whether the annotation is on top ('top') or below ('bottom') the scalebar. Horizontal alignment of the annotation text relative to the scalebar ( hat ) can be 'center' (default), 'left' or 'right'. In the figure the position of the scalebar, its anchor point, is shown as a red circle. ax.xscalebar(0.0, 0.9, 2, 's', ha='left', va='top') ax.xscalebar(0.5, 0.9, 2, 's', ha='center', va='top') ax.xscalebar(1.0, 0.9, 2, 's', ha='right', va='top') ax.xscalebar(0.0, 0.5, 2, 's', ha='left', va='bottom') ax.xscalebar(0.5, 0.5, 2, 's', ha='center', va='bottom') ax.xscalebar(1.0, 0.5, 2, 's', ha='right', va='bottom') ax.xscalebar(0.0, 0.1, 2, 's', ha='left', va='bottom', hat='left') ax.xscalebar(0.5, 0.1, 2, 's', ha='center', va='bottom', hat='center') ax.xscalebar(1.0, 0.1, 2, 's', ha='right', va='bottom', hat='right') The third argument sets the length of the scale bar in data coordinates of the x-axis, followed by a string setting the unit of the scale. Y Scalebars yscalebar() draws and annotates a vertical scalebar, visualizing the scale of the y-axis. ax.yscalebar(1.05, 0.0, 1, 'mV', ha='right', va='bottom') For vertical scalebars, va (vertical alignment) determines whether the anchor is on the 'top', 'center', or 'bottom' of the scalebar. The horizontal alignment ( ha ) determines whether the annotation is to the 'left' or to the 'right' of the scale bar. Vertical alignment of the annotation text relative to the scalebar ( vat ) can be 'center' (default), 'top' or 'bottom'. In the figure the position of the scalebar, the anchor point, is shown as a red circle. ax.yscalebar(0.3, 1.0, 1, 'mV', ha='left', va='top') ax.yscalebar(0.3, 0.5, 1, 'mV', ha='left', va='center') ax.yscalebar(0.3, 0.0, 1, 'mV', ha='left', va='bottom') ax.yscalebar(0.7, 1.0, 1, 'mV', ha='right', va='top') ax.yscalebar(0.7, 0.5, 1, 'mV', ha='right', va='center') ax.yscalebar(0.7, 0.0, 1, 'mV', ha='right', va='bottom') X-Y Scalebars scalebars() draws and annotates both a horizontal and a vertical scalebar, visualizing the scale of the x- and the y-axis. Horizontal alignment ( ha ) determines whether the anchor point and the vertical scalebar is on the 'left' or on the 'right' of the horizontal scalebar. Vertical alignment ( va ) determines whether the anchor point and the horizontal scalebar are at the 'top' or 'bottom' of the vertical scalebar. Again, hat and vat allow to control the position of the annotation texts relative to the scalebars. In the figure the position of the scalebar, the anchor point, is shown as a red circle. ax.scalebars(0.2, 0.8, 2, 1, 's', 'mV', ha='left', va='top') ax.scalebars(0.8, 0.8, 2, 1, 's', 'mV', ha='right', va='top') ax.scalebars(0.2, 0.1, 2, 1, 's', 'mV', ha='left', va='bottom') ax.scalebars(0.8, 0.1, 2, 1, 's', 'mV', ha='right', va='bottom') Styles The line width and the color of the scalebar can be set by the lw and color keyword arguments. The horizontal and vertical scalebars can have in addition start and stop markers. These are lines perpendicular to the scalebar line. Half of their length is set by capsize and their width by clw . ax.xscalebar(0.0, 0.8, 2, 'mm', ha='left', va='bottom', lw=3) ax.xscalebar(0.0, 0.3, 2, 'mm', ha='left', va='bottom', lw=6) ax.xscalebar(1.0, 0.8, 2, 'mm', ha='right', va='bottom', lw=4, capsize=4, clw=2) ax.xscalebar(1.0, 0.3, 2, 'mm', ha='right', va='bottom', lw=4, capsize=6, clw=1) Import and use the scalebar_params() function to modify default rc settings defining the style of the scalebars: scalebar_params(format_large='%.0f', format_small='%.1f', lw=3, capsize=0, clw=0.5) Ideally you use the scalebar functions without specifying the lw , color , capsize , clw , and font arguments and control them by a central call to scalebar_params() .","title":"Scalebars"},{"location":"scalebars/#scalebars-module","text":"Scalebars are an alternative to xticks and yticks. They visualize scales by the length of a bar. ax.scalebars(1.05, 0.0, 2, 1, 's', 'mV', ha='right', va='bottom') Do not use scalebars if a specific value on the axis (most likely zero) has a special meaning! The scalebar module installs the three functions xscalebar() yscalebar() scalebars() on matplotlib axes for drawing and annotating horizontal or vertical scalebars, or both. import matplotlib.pyplot as plt from plottools.scalebars import scalebar_params fig, ax = plt.subplots()","title":"Scalebars module"},{"location":"scalebars/#x-scalebars","text":"xscalebar() draws and annotates a horizontal scalebar, visualizing the scale of the x-axis. ax.xscalebar(1.0, 0.0, 2, 's', ha='right', va='bottom') The first two arguments of the scalebar functions set the anchor point on which the scalebar is positioned. The scalebar position is given in relative coordinates of the axes (ranging from 0 to 1). For horizontal scalebars, ha (horizontal alignment) determines whether the anchor is on the 'left', 'center', or 'right' of the scalebar. The vertical alignment ( va ) determines whether the annotation is on top ('top') or below ('bottom') the scalebar. Horizontal alignment of the annotation text relative to the scalebar ( hat ) can be 'center' (default), 'left' or 'right'. In the figure the position of the scalebar, its anchor point, is shown as a red circle. ax.xscalebar(0.0, 0.9, 2, 's', ha='left', va='top') ax.xscalebar(0.5, 0.9, 2, 's', ha='center', va='top') ax.xscalebar(1.0, 0.9, 2, 's', ha='right', va='top') ax.xscalebar(0.0, 0.5, 2, 's', ha='left', va='bottom') ax.xscalebar(0.5, 0.5, 2, 's', ha='center', va='bottom') ax.xscalebar(1.0, 0.5, 2, 's', ha='right', va='bottom') ax.xscalebar(0.0, 0.1, 2, 's', ha='left', va='bottom', hat='left') ax.xscalebar(0.5, 0.1, 2, 's', ha='center', va='bottom', hat='center') ax.xscalebar(1.0, 0.1, 2, 's', ha='right', va='bottom', hat='right') The third argument sets the length of the scale bar in data coordinates of the x-axis, followed by a string setting the unit of the scale.","title":"X Scalebars"},{"location":"scalebars/#y-scalebars","text":"yscalebar() draws and annotates a vertical scalebar, visualizing the scale of the y-axis. ax.yscalebar(1.05, 0.0, 1, 'mV', ha='right', va='bottom') For vertical scalebars, va (vertical alignment) determines whether the anchor is on the 'top', 'center', or 'bottom' of the scalebar. The horizontal alignment ( ha ) determines whether the annotation is to the 'left' or to the 'right' of the scale bar. Vertical alignment of the annotation text relative to the scalebar ( vat ) can be 'center' (default), 'top' or 'bottom'. In the figure the position of the scalebar, the anchor point, is shown as a red circle. ax.yscalebar(0.3, 1.0, 1, 'mV', ha='left', va='top') ax.yscalebar(0.3, 0.5, 1, 'mV', ha='left', va='center') ax.yscalebar(0.3, 0.0, 1, 'mV', ha='left', va='bottom') ax.yscalebar(0.7, 1.0, 1, 'mV', ha='right', va='top') ax.yscalebar(0.7, 0.5, 1, 'mV', ha='right', va='center') ax.yscalebar(0.7, 0.0, 1, 'mV', ha='right', va='bottom')","title":"Y Scalebars"},{"location":"scalebars/#x-y-scalebars","text":"scalebars() draws and annotates both a horizontal and a vertical scalebar, visualizing the scale of the x- and the y-axis. Horizontal alignment ( ha ) determines whether the anchor point and the vertical scalebar is on the 'left' or on the 'right' of the horizontal scalebar. Vertical alignment ( va ) determines whether the anchor point and the horizontal scalebar are at the 'top' or 'bottom' of the vertical scalebar. Again, hat and vat allow to control the position of the annotation texts relative to the scalebars. In the figure the position of the scalebar, the anchor point, is shown as a red circle. ax.scalebars(0.2, 0.8, 2, 1, 's', 'mV', ha='left', va='top') ax.scalebars(0.8, 0.8, 2, 1, 's', 'mV', ha='right', va='top') ax.scalebars(0.2, 0.1, 2, 1, 's', 'mV', ha='left', va='bottom') ax.scalebars(0.8, 0.1, 2, 1, 's', 'mV', ha='right', va='bottom')","title":"X-Y Scalebars"},{"location":"scalebars/#styles","text":"The line width and the color of the scalebar can be set by the lw and color keyword arguments. The horizontal and vertical scalebars can have in addition start and stop markers. These are lines perpendicular to the scalebar line. Half of their length is set by capsize and their width by clw . ax.xscalebar(0.0, 0.8, 2, 'mm', ha='left', va='bottom', lw=3) ax.xscalebar(0.0, 0.3, 2, 'mm', ha='left', va='bottom', lw=6) ax.xscalebar(1.0, 0.8, 2, 'mm', ha='right', va='bottom', lw=4, capsize=4, clw=2) ax.xscalebar(1.0, 0.3, 2, 'mm', ha='right', va='bottom', lw=4, capsize=6, clw=1) Import and use the scalebar_params() function to modify default rc settings defining the style of the scalebars: scalebar_params(format_large='%.0f', format_small='%.1f', lw=3, capsize=0, clw=0.5) Ideally you use the scalebar functions without specifying the lw , color , capsize , clw , and font arguments and control them by a central call to scalebar_params() .","title":"Styles"},{"location":"spines/","text":"Spines module Control spine visibility, bounds (extend of spine), position (moving it outward or inward), and arrows. import matplotlib.pyplot as plt from plottools.spines import spines_params spines_params('lb') fig, (ax0, ax1, ax2) = plt.subplots(1, 3) Spine visibility The ax.show_spines() functions controls visibility of spines and modifies tick and label positions accordingly. ax0.show_spines('lb') ax1.show_spines('bt') ax2.show_spines('tr') Spine bounds The length of the spine can span the full length of the axis as set by the axis's limits ( 'full' ), the extend of the data ( 'data' ), the range between the minimum and maximum tick location ( 'ticks' ). or any other range on the corresponding axis. ax0.set_spines_bounds('lb', 'full') ax1.set_spines_bounds('lb', 'data') ax2.set_spines_bounds('lb', 'ticks') Spine position Spines can be moved outward (positive offset in points) or inward (negative offset). ax0.set_spines_outward('lb', 0) ax1.set_spines_outward('lb', 10) ax2.set_spines_outward('lb', -10) Arrowed spines Spines can get an arrow head. spines_params(spines='', height=10) ax0.arrow_spines('lb') ax1.arrow_spines('lb', flush=1.0) ax2.arrow_spines('lb', flush=2.0) Default spine appearance The spines_params() controls the default appearance of spines.","title":"Spines"},{"location":"spines/#spines-module","text":"Control spine visibility, bounds (extend of spine), position (moving it outward or inward), and arrows. import matplotlib.pyplot as plt from plottools.spines import spines_params spines_params('lb') fig, (ax0, ax1, ax2) = plt.subplots(1, 3)","title":"Spines module"},{"location":"spines/#spine-visibility","text":"The ax.show_spines() functions controls visibility of spines and modifies tick and label positions accordingly. ax0.show_spines('lb') ax1.show_spines('bt') ax2.show_spines('tr')","title":"Spine visibility"},{"location":"spines/#spine-bounds","text":"The length of the spine can span the full length of the axis as set by the axis's limits ( 'full' ), the extend of the data ( 'data' ), the range between the minimum and maximum tick location ( 'ticks' ). or any other range on the corresponding axis. ax0.set_spines_bounds('lb', 'full') ax1.set_spines_bounds('lb', 'data') ax2.set_spines_bounds('lb', 'ticks')","title":"Spine bounds"},{"location":"spines/#spine-position","text":"Spines can be moved outward (positive offset in points) or inward (negative offset). ax0.set_spines_outward('lb', 0) ax1.set_spines_outward('lb', 10) ax2.set_spines_outward('lb', -10)","title":"Spine position"},{"location":"spines/#arrowed-spines","text":"Spines can get an arrow head. spines_params(spines='', height=10) ax0.arrow_spines('lb') ax1.arrow_spines('lb', flush=1.0) ax2.arrow_spines('lb', flush=2.0)","title":"Arrowed spines"},{"location":"spines/#default-spine-appearance","text":"The spines_params() controls the default appearance of spines.","title":"Default spine appearance"},{"location":"starter/","text":"Getting started with matplotlib This is a quick introduction into generating figures with python and the matplotlib package. Use it for hints (and links) on the most important commands. Check then their documentation for further details. Import the matplotlib package: import matplotlib.pyplot as plt and generate some time series data for plotting: import numpy as np t = np.arange(0.0, 1.0, 0.01) # one second with time step 0.01 x = np.sin(2.0*np.pi*10.0*t) # 10Hz sine wave Then a quick way to plot this is plt.plot(t, x) plt.show() Do not forget the show() ! This command displays the plot in a new window and let you interact with it (zooming and panning). By the way, these features have short keys: press o for zooming or p for panning. backspace brings you back. f is fullscreen mode. This is great for quickly checking data in your code. For properly annotating a plot and for producing nice figures we use the object-oriented interface of matplotlib (see the object-oriented API and the lifecycle of a plot ). This is described in the following: Single plot in a figure Generate a figure and an axes using the plt.subplots() function: fig, ax = plt.subplots() Then ax is a single matplotlib axes. This is a plot, a coordinate system, in which you can draw and annotate your data: ax.plot(t, x) ax.set_xlim(0, 0.2) ax.set_xlabel('Time [s]') ax.set_ylabel('Voltage [mV]') Plot commands A nice overview on available plot types is given here . See the matplotlib.axes API for a (long) list of member functions, including various types of plots and annotations. Here is a selection of often used plot commands: plot(x, y) : plot y versus x with markers and connected by lines. errorbar(x, y, yerr) : plot errorbars (both vertical and horizontal ones) scatter(x, y, size, color) : plot y versus x with varying marker size and color. fill_between(x, y1, y2) : fill area between a curve and an axis (or another curve). hist(x, bins) : histogram (see also np.histogram() and ax.bar() ). boxplot(x) : box-whisker plot. contour(x, y, z) : contour lines. pcolormesh(x, y, z) : pseudocolor plot of a matrix with specified x- and y-axis ranges. imshow(z) : plot an image - (almost) never use it for pseudocolor plots of matrices, use pcolormesh() instead. Setting colors, lines, and markers Further key-word arguments to the plot commands allow to change colors, lines, and markers. In the following some of the more commonly used ones are listed. Lines: color or c : color specification, e.g. 'red' , '#DD0000' , or 'C3' (forth color of color cycle), see specifying colors . linewidth or lw : width of connecting lines. linestyle or ls : solid, dashed, or dotted: '-', '--', '-.', ':', ''. Markers: marker : the marker symbol, e.g. '.', 'o', 'v', 's', 'D', 'p', 'h', 'x', '+', '*', etc. see matplotlib.markers for a table. markersize or ms : size of the marker symbol. markerfacecolor or mfc : fill color of the marker, e.g. 'green' or '#00CC00' markeredgecolor or mec : color of the outline of the marker, e.g. 'blue' or '#0000DD' markeredgewidth or mew : width of the marker outline. Other: label : a label for the legend (see below). clip_on : set to False if you do not want, for example, marker symbols to be clipped. zorder : some number specifying the order in which elements are drawn into the plot. Higher numbers are drawn on top of lower numbers. Logarithmic axis For a logarithmic x-axis use ax.set_xscale() : ax.set_xlim(0.01, 1.0) ax.set_xscale('log') Likewise for the y-axis. Make sure the data range starts at positive (non-zero) values using ax.set_xlim() and ax.set_ylim() . Legend When you plot several data sets into an axes, you might want to add a legend to your plot. Pass a label to the plot commands and then call legend() : ax.plot(t, x, label='one') ax.plot(t, 1.5*x, label='two') ax.plot(t, 2.2*x, label='three') ax.legend(loc='upper right') Annotation You can place some text somewhere in (or outside) your plot using the text() function: ax.text(12.7, 8.2, 'a note') The first two arguments are the x- and y-coordinate of the text in data coordinates. Very useful is to specify the position of the text in relative axes coordinates: ax.text(0.9, 0.9, 'another note', ha='right', transform=ax.transAxes) This text is placed right aligned ( ha='right' ) in the top right corner. Save figure to a file fig is a matplotlib figure. In this example it holds just one axes, but it can have many more (see next section). Each window you get with plt.show() contains a matplotlib figure. And you can save a matplotlib figure to a file using the savefig() function: fig.savefig('myplot.pdf') You can save the figure into pdf , svg , png , jpg and tex files. Just supply the right file extension. If you also want to display your figure on screen, then call plt.show() after fig.savefig() , because on exit (closing the window), plt.show() destroys the figure. Multiple plots in a figure The simplest scenario is having a grid of subplots. The following example generates two rows and three columns of axes (=subplots) using the subplots() function: fig, axs = plt.subplots(2, 3) Now, axs is a 2-dimensional numpy array holding the six axes that we use like this: axs[0,0].plot(t, x) # top left plot axs[1,2].plot(t, 2*x) # bottom right plot Alternatively to indexing the axes by both a row and a column index, you can flatten the axes array: for k, ax in enumarate(axs.flat): ax.plot(x, k*y, label=f'{k}') A single row or column of subplots can also be initialized like this: fig, (ax1, ax2) = plt.subplots(1, 2) With the sharex and sharey key words, you can tie the respective axis of the subplots together, such that is you zoom into one subplot, the other ones get zoomed as well: fig, axs = plt.subplots(2, 3, sharex=True, sharey=True) A very useful and less well known feature is that the relative widths and heights of the columns and rows of a grid of subplots can be specified like this: fig, axs = plt.subplots(2, 3, gridspec_kw=dict(width_ratios=[3, 1, 1], height_ratios=[4, 1])) The width_ratios and height_ratios give for each column/row a relative width/height. For more details on how to layout subplots you definitely want to read the Arranging multiple Axes in a Figure tutorial and the GridSpec tutorial . Also check out the subplot_mosaic() function. Customizing figure layout First of all, you want to specify the size of your figure. Make each figure as large as you want it to be in your manuscript or presentation to ensure that the plot labels of all your figures have the same font size ( no scaling of the figures in the manuscript or presentation). fig, axs = plt.subplots(2, 3, figsize=(8, 5)) # in inch! Unfortunately, the figsize argument takes the width and the height of the figure measured in inches. Hey - we are doing science here and want SI units! To specify your figure size in centimeters you need to divide by 2.54 cm/inch: fig, axs = plt.subplots(2, 3, figsize=(12/2.54, 8/2.54)) # in cm Second, you want your plots to nicely fill the figure (no extra whitespace at the borders). For this use fig.subplots_adjust(left=0.2, right=0.95, top=0.95, bottom=0.1) These are fractions of the full figure size. right and top are absolute coordinates, not the width and the height of the subplots. Adapt them as needed. After a while you get a feeling for good values and adjusting them gets easy. Third, adjust the whitespace between the subplots. Don't let your urge to give each subplot as much space as possible win. Figures usually look much better with quite a lot of whitespace between them: fig.subplots_adjust(wspace=0.5, hspace=0.4) Both wspace and hspace specify the amount of whitespace relative to the average width/height of the subplots. hspace stands for \"height\" not \"horizontal\". Customizing figure design Label fonts, default colors, etc. can be customized globally for all your plots via rcParams . This is a must-read! For example, to set the standard font size to 11pt and have somewhat smaller tick labels you may call plt.rcParams['font.size'] = 11 plt.rcParams['xtick.labelsize'] = 'small' plt.rcParams['ytick.labelsize'] = 'small' before you create any figures and axes. Further reading and cheat sheets A gallery of various plots with example code. matplotlib provides some nice cheat sheets . And there are a number of tutorials . Figure guidelines Continue reading with some figure guidelines .","title":"Getting started with matplotlib"},{"location":"starter/#getting-started-with-matplotlib","text":"This is a quick introduction into generating figures with python and the matplotlib package. Use it for hints (and links) on the most important commands. Check then their documentation for further details. Import the matplotlib package: import matplotlib.pyplot as plt and generate some time series data for plotting: import numpy as np t = np.arange(0.0, 1.0, 0.01) # one second with time step 0.01 x = np.sin(2.0*np.pi*10.0*t) # 10Hz sine wave Then a quick way to plot this is plt.plot(t, x) plt.show() Do not forget the show() ! This command displays the plot in a new window and let you interact with it (zooming and panning). By the way, these features have short keys: press o for zooming or p for panning. backspace brings you back. f is fullscreen mode. This is great for quickly checking data in your code. For properly annotating a plot and for producing nice figures we use the object-oriented interface of matplotlib (see the object-oriented API and the lifecycle of a plot ). This is described in the following:","title":"Getting started with matplotlib"},{"location":"starter/#single-plot-in-a-figure","text":"Generate a figure and an axes using the plt.subplots() function: fig, ax = plt.subplots() Then ax is a single matplotlib axes. This is a plot, a coordinate system, in which you can draw and annotate your data: ax.plot(t, x) ax.set_xlim(0, 0.2) ax.set_xlabel('Time [s]') ax.set_ylabel('Voltage [mV]')","title":"Single plot in a figure"},{"location":"starter/#plot-commands","text":"A nice overview on available plot types is given here . See the matplotlib.axes API for a (long) list of member functions, including various types of plots and annotations. Here is a selection of often used plot commands: plot(x, y) : plot y versus x with markers and connected by lines. errorbar(x, y, yerr) : plot errorbars (both vertical and horizontal ones) scatter(x, y, size, color) : plot y versus x with varying marker size and color. fill_between(x, y1, y2) : fill area between a curve and an axis (or another curve). hist(x, bins) : histogram (see also np.histogram() and ax.bar() ). boxplot(x) : box-whisker plot. contour(x, y, z) : contour lines. pcolormesh(x, y, z) : pseudocolor plot of a matrix with specified x- and y-axis ranges. imshow(z) : plot an image - (almost) never use it for pseudocolor plots of matrices, use pcolormesh() instead.","title":"Plot commands"},{"location":"starter/#setting-colors-lines-and-markers","text":"Further key-word arguments to the plot commands allow to change colors, lines, and markers. In the following some of the more commonly used ones are listed. Lines: color or c : color specification, e.g. 'red' , '#DD0000' , or 'C3' (forth color of color cycle), see specifying colors . linewidth or lw : width of connecting lines. linestyle or ls : solid, dashed, or dotted: '-', '--', '-.', ':', ''. Markers: marker : the marker symbol, e.g. '.', 'o', 'v', 's', 'D', 'p', 'h', 'x', '+', '*', etc. see matplotlib.markers for a table. markersize or ms : size of the marker symbol. markerfacecolor or mfc : fill color of the marker, e.g. 'green' or '#00CC00' markeredgecolor or mec : color of the outline of the marker, e.g. 'blue' or '#0000DD' markeredgewidth or mew : width of the marker outline. Other: label : a label for the legend (see below). clip_on : set to False if you do not want, for example, marker symbols to be clipped. zorder : some number specifying the order in which elements are drawn into the plot. Higher numbers are drawn on top of lower numbers.","title":"Setting colors, lines, and markers"},{"location":"starter/#logarithmic-axis","text":"For a logarithmic x-axis use ax.set_xscale() : ax.set_xlim(0.01, 1.0) ax.set_xscale('log') Likewise for the y-axis. Make sure the data range starts at positive (non-zero) values using ax.set_xlim() and ax.set_ylim() .","title":"Logarithmic axis"},{"location":"starter/#legend","text":"When you plot several data sets into an axes, you might want to add a legend to your plot. Pass a label to the plot commands and then call legend() : ax.plot(t, x, label='one') ax.plot(t, 1.5*x, label='two') ax.plot(t, 2.2*x, label='three') ax.legend(loc='upper right')","title":"Legend"},{"location":"starter/#annotation","text":"You can place some text somewhere in (or outside) your plot using the text() function: ax.text(12.7, 8.2, 'a note') The first two arguments are the x- and y-coordinate of the text in data coordinates. Very useful is to specify the position of the text in relative axes coordinates: ax.text(0.9, 0.9, 'another note', ha='right', transform=ax.transAxes) This text is placed right aligned ( ha='right' ) in the top right corner.","title":"Annotation"},{"location":"starter/#save-figure-to-a-file","text":"fig is a matplotlib figure. In this example it holds just one axes, but it can have many more (see next section). Each window you get with plt.show() contains a matplotlib figure. And you can save a matplotlib figure to a file using the savefig() function: fig.savefig('myplot.pdf') You can save the figure into pdf , svg , png , jpg and tex files. Just supply the right file extension. If you also want to display your figure on screen, then call plt.show() after fig.savefig() , because on exit (closing the window), plt.show() destroys the figure.","title":"Save figure to a file"},{"location":"starter/#multiple-plots-in-a-figure","text":"The simplest scenario is having a grid of subplots. The following example generates two rows and three columns of axes (=subplots) using the subplots() function: fig, axs = plt.subplots(2, 3) Now, axs is a 2-dimensional numpy array holding the six axes that we use like this: axs[0,0].plot(t, x) # top left plot axs[1,2].plot(t, 2*x) # bottom right plot Alternatively to indexing the axes by both a row and a column index, you can flatten the axes array: for k, ax in enumarate(axs.flat): ax.plot(x, k*y, label=f'{k}') A single row or column of subplots can also be initialized like this: fig, (ax1, ax2) = plt.subplots(1, 2) With the sharex and sharey key words, you can tie the respective axis of the subplots together, such that is you zoom into one subplot, the other ones get zoomed as well: fig, axs = plt.subplots(2, 3, sharex=True, sharey=True) A very useful and less well known feature is that the relative widths and heights of the columns and rows of a grid of subplots can be specified like this: fig, axs = plt.subplots(2, 3, gridspec_kw=dict(width_ratios=[3, 1, 1], height_ratios=[4, 1])) The width_ratios and height_ratios give for each column/row a relative width/height. For more details on how to layout subplots you definitely want to read the Arranging multiple Axes in a Figure tutorial and the GridSpec tutorial . Also check out the subplot_mosaic() function.","title":"Multiple plots in a figure"},{"location":"starter/#customizing-figure-layout","text":"First of all, you want to specify the size of your figure. Make each figure as large as you want it to be in your manuscript or presentation to ensure that the plot labels of all your figures have the same font size ( no scaling of the figures in the manuscript or presentation). fig, axs = plt.subplots(2, 3, figsize=(8, 5)) # in inch! Unfortunately, the figsize argument takes the width and the height of the figure measured in inches. Hey - we are doing science here and want SI units! To specify your figure size in centimeters you need to divide by 2.54 cm/inch: fig, axs = plt.subplots(2, 3, figsize=(12/2.54, 8/2.54)) # in cm Second, you want your plots to nicely fill the figure (no extra whitespace at the borders). For this use fig.subplots_adjust(left=0.2, right=0.95, top=0.95, bottom=0.1) These are fractions of the full figure size. right and top are absolute coordinates, not the width and the height of the subplots. Adapt them as needed. After a while you get a feeling for good values and adjusting them gets easy. Third, adjust the whitespace between the subplots. Don't let your urge to give each subplot as much space as possible win. Figures usually look much better with quite a lot of whitespace between them: fig.subplots_adjust(wspace=0.5, hspace=0.4) Both wspace and hspace specify the amount of whitespace relative to the average width/height of the subplots. hspace stands for \"height\" not \"horizontal\".","title":"Customizing figure layout"},{"location":"starter/#customizing-figure-design","text":"Label fonts, default colors, etc. can be customized globally for all your plots via rcParams . This is a must-read! For example, to set the standard font size to 11pt and have somewhat smaller tick labels you may call plt.rcParams['font.size'] = 11 plt.rcParams['xtick.labelsize'] = 'small' plt.rcParams['ytick.labelsize'] = 'small' before you create any figures and axes.","title":"Customizing figure design"},{"location":"starter/#further-reading-and-cheat-sheets","text":"A gallery of various plots with example code. matplotlib provides some nice cheat sheets . And there are a number of tutorials .","title":"Further reading and cheat sheets"},{"location":"starter/#figure-guidelines","text":"Continue reading with some figure guidelines .","title":"Figure guidelines"},{"location":"structure/","text":"How to structure your code With our insights from coding a figure and from the guide lines we arrive on some best-practice tips on how to structure code for figures, such that: Others, including your future self, are able to modify your figures. Plot appearance can be changed quickly from a central module. Design and content are separated. It makes fun to improve your plots. File organization Let's assume we need three figures that we call basicdata , methods , and coolresult . Then for each of the figures we will have a separate python script ( guide line 1 ) with the respective name ( guide line 2 ). That way everybody (or a Makefile for that matter) easily finds the script generating that figure. In addition, we will have a script defining the appearance of the figures ( guide line 4 ) that will be imported by all of the scripts generating the actual figures. Let's call that script plotstyle.py . This file is central for the separation of content from layout. We keep the file hierarchy flat and simply have four files in our working directory: plotstyle.py basicdata.py methods.py coolresult.py Data files can also go along with the python scripts, or in a separate sub-direcotry, for example data/ . Object-oriented matplotlib interface You should exclusively use the object-oriented interface of matplotlib. That way it is always clear on which axes plot commands are applied. And matplotlib recommends using the object-oriented interface anyways (check out the object-oriented API and the lifecycle of a plot ). The plotstyle module The plotstyle.py module provides a function that we name here plot_style() . This function contains code defining the overall design of your plots. It sets some rcParams and defines some plotting styles . For now we just define two line styles and set the ticks to point outwards: import matplotlib.pyplot as plt def plot_style(): # namespace for plotting styles: class s: pass s.lsSmall = dict(color='tab:red', lw=2) s.lsLarge = dict(color='tab:orange', lw=2) # global settings: plt.rcParam['xtick.direction'] = 'out' plt.rcParam['ytick.direction'] = 'out' return s Of course, this function will be much larger as you keep working on your plots. Step by step you improve and expand on the rcParams and the more data you plot the more plotting styles you need to add. Working on the plotstyle module requires some effort in the very beginning. Over time, however, the module converges to a state where you only occasionally add another plotting styles . Choose the names of the plotting styles , then they are easy to use. And of course you can use it for all your aother manuscripts, posters, or presentations. Just copy it over and adapt it if necessary. Plotting scripts So how to write a script generating a specific figure? Let's start simple with the script basicdata.py generating a figure with just a single panel (subplot). Package imports First of all we need the usual imports of numpy , scipy , and pandas as required, of course of matplotlib.pyplot and also of the plot_style() function from our central plotstyle.py module: import numpy as np import matplotlib.pyplot as plt from plotstyle import plot_style In contrast to your analysis scripts, try to keep the number of imported packages as low as possible. This reduces dependencies to a minimum and makes it easier to reuse the code for generating the figures. A low number of imports should be no problem, because the plotting scripts do only the plotting and are not supposed to do any complex data analysis. The results of complex computation are stored in files. The plotting scripts just need to read these files and plot their content - not much overhead is needed. In particular this implies that we do not need to import numba for plotting! And embed() from the IPython package should not be needed - this is for more complicated issues than plotting. A well readable import list is necessary so that one can easily trace back the origin of some functions. To support this import only what is needed by your script import every package/symbol only once sort the imports according to package - common packages first, your own modules last. Main code We start out at the bottom of the script with the following two lines: if __name__ == \"__main__\": s = plot_style() The call of the plot_style() function sets up the plot appearance and returns a namespace containing various plotting styles as dicussed above. The following lines of code should set up the figure, call functions generating the actual plots, and save the figure to a file. In case of our simple example this looks like this: fig, ax = plt.subplots(figsize=(6, 4)) fig.subplots_adjust(top=0.95, bottom=0.1, left=0.1, right=0.95) plot_data(ax, s) fig.savefig('basicdata.pdf') The call to plt.subplots() returns a new figure fig of the specified size and a single axes ax . Most certainly you need to adjust the figure margins via fig.subplots_adjust() . A good plot does not have excessive white space on the borders. In particular if you include your figure in a LaTeX document it is much simpler to handle when it tightly fills the figure canvas. fig.tight_layout() usually does not work, but you may give a try to the constrained_layout argument to plt.subplots() . A problem with fig.subplots_adjust() is, that the figure margins are specified relative to the figure size. Whenever changing the figure size you need to readjust the figure margins. The following function call to plot_data(ax) does the actual plotting. We discuss this in the next section. Finally, the figure needs to be saved. The filename should be the same as the name of the script to allow others to find the script given the figure file. You may omit the file extension if you have set the rcParam savefig.format to your preferred format. In the context of scientific publications this should be a vector graphic format like pdf or svg . Of course, you may stuff all this figure code into a function. Plot code The basic unit of any figure is a plot, a single matplotlib axes. You may rearrange the position of an axes within a figure or even move an axes to another figure. To allow for this flexibility, collecting all code needed to draw the content of an axes into a single dedicated function is central. This function takes as the first argument the axes into which it should draw. As a second argument it takes the namespace with the plotting styles. For every axes make a function that does the plotting and that takes this axes as an argument. In our example this is the plot_data() function that might look like this: def plot_data(ax, s): x, y = load_data() ax.plot(x, y, **lsSmall) ax.set_xlabel('x') ax.set_ylabel('y') The first part of the function loads or generates the data to be plotted - symbolized by the load_data() function call. The second part does the actual plotting. If you manage to separate content from design well, then the functions for the actual plotting are usually simple and sweet. Everybody can comprehend what is going on. The function - the plot - can be easily reused in a different context. Alternatively we could have called load_data() outside the plot_data() function and pass the loaded data as arguments to the plot function: x, y = load_data() plot_data(ax, s, x, y) Then plot_data() would only contain plot commands. This is in particular useful for a multi-panel plot, where many panels use the same data for their plotting. On the other hand, in many cases the data are loaded or generated in no time. So from a performance point of view it does not hurt to load/generate them for any plot within each plot function. But with the load function inside you need less function arguments and the plot function can be more easily moved somewhere else. Complexity/simplicity of the plot function Most of the design of the plots is handled by the central plot_style() function as described above. Then the plot function anly needs to provide content and usually gets quite simple. What is left to specify simply is: what to plot, e.g. ax.plot(x, y) . Of course, this might require several plot commands , but if you provide the data such that they can be more or less directly passed to the plot commands, this stays simple. how to annotate, e.g. ax.text() , ax.annotate() and/or some arrows. axis limits, e.g. ax.set_xlim() . tick marks (actually that often is a matter of design and should not be here...). axis scaling, e.g. ax.set_xscale('log') . axis labels, e.g. ax.set_xlabel() . That's it. No hiding of spines, no fixing of tick positions, etc. All these design issues should at least be bundled in some helper functions that would go into the central plotstyle.py module. Having code for the design directly in the plot function makes it very tedious to change the design later on, because this then needs to be changed in every plot function. Anyways, repeating the same commands over and over in all the different plot functions is not considered good coding style! Why should it be different for coding your figures? How to provide the data for the plotting function is the only other issue. You should make sure by means of other scripts that the data are available in appropriate formats. The data should be stored in a way that makes it simple to plot them. Then it is simply a matter of loading a file and selecting, for example, the relevant rows and columns. No rearranging, fixing, or whatever annoying stuff should be needed to make the data plotable. All this should go into scripts that output the files on which the plotting is based. The big advantages of keeping the plotting- as well as the data-handling code simple are less arguments need to be passed to the plot function, which makes the code less cluttered, and dependencies of the plot function are reduced, which makes it simpler to copy (or import) the plot function to another script and use it there. Multipanel figures Scripts for multipanel figures follow the same structure as the single-panel script discussed so far. We have the same minimal imports. The main code setting up the figure is more complex, of course. For example, the main code in a coolresult.py script might look like this: if __name__ == \"__main__\": plot_style() fig, axs = plt.subplots(2, 2, figsize=(6, 4)) fig.subplots_adjust(top=0.95, bottom=0.1, left=0.1, right=0.95, hspace=0.6, wspace=0.6) plot_waveform(axs[0,0]) plot_temperature(axs[0,1]) plot_signal_n_power(axs[1,0], axs[1,1]) fig.savefig('coolresult.pdf') With the plt.subplots() we generate an array of axes. We pass hspace and wspace arguments to fig.subplots_adjust() . Try large values! You will be surprised how much better your plot looks with lot's of white space between the panels, althought the panels get smaller.","title":"How to structure your code"},{"location":"structure/#how-to-structure-your-code","text":"With our insights from coding a figure and from the guide lines we arrive on some best-practice tips on how to structure code for figures, such that: Others, including your future self, are able to modify your figures. Plot appearance can be changed quickly from a central module. Design and content are separated. It makes fun to improve your plots.","title":"How to structure your code"},{"location":"structure/#file-organization","text":"Let's assume we need three figures that we call basicdata , methods , and coolresult . Then for each of the figures we will have a separate python script ( guide line 1 ) with the respective name ( guide line 2 ). That way everybody (or a Makefile for that matter) easily finds the script generating that figure. In addition, we will have a script defining the appearance of the figures ( guide line 4 ) that will be imported by all of the scripts generating the actual figures. Let's call that script plotstyle.py . This file is central for the separation of content from layout. We keep the file hierarchy flat and simply have four files in our working directory: plotstyle.py basicdata.py methods.py coolresult.py Data files can also go along with the python scripts, or in a separate sub-direcotry, for example data/ .","title":"File organization"},{"location":"structure/#object-oriented-matplotlib-interface","text":"You should exclusively use the object-oriented interface of matplotlib. That way it is always clear on which axes plot commands are applied. And matplotlib recommends using the object-oriented interface anyways (check out the object-oriented API and the lifecycle of a plot ).","title":"Object-oriented matplotlib interface"},{"location":"structure/#the-plotstyle-module","text":"The plotstyle.py module provides a function that we name here plot_style() . This function contains code defining the overall design of your plots. It sets some rcParams and defines some plotting styles . For now we just define two line styles and set the ticks to point outwards: import matplotlib.pyplot as plt def plot_style(): # namespace for plotting styles: class s: pass s.lsSmall = dict(color='tab:red', lw=2) s.lsLarge = dict(color='tab:orange', lw=2) # global settings: plt.rcParam['xtick.direction'] = 'out' plt.rcParam['ytick.direction'] = 'out' return s Of course, this function will be much larger as you keep working on your plots. Step by step you improve and expand on the rcParams and the more data you plot the more plotting styles you need to add. Working on the plotstyle module requires some effort in the very beginning. Over time, however, the module converges to a state where you only occasionally add another plotting styles . Choose the names of the plotting styles , then they are easy to use. And of course you can use it for all your aother manuscripts, posters, or presentations. Just copy it over and adapt it if necessary.","title":"The plotstyle module"},{"location":"structure/#plotting-scripts","text":"So how to write a script generating a specific figure? Let's start simple with the script basicdata.py generating a figure with just a single panel (subplot).","title":"Plotting scripts"},{"location":"structure/#package-imports","text":"First of all we need the usual imports of numpy , scipy , and pandas as required, of course of matplotlib.pyplot and also of the plot_style() function from our central plotstyle.py module: import numpy as np import matplotlib.pyplot as plt from plotstyle import plot_style In contrast to your analysis scripts, try to keep the number of imported packages as low as possible. This reduces dependencies to a minimum and makes it easier to reuse the code for generating the figures. A low number of imports should be no problem, because the plotting scripts do only the plotting and are not supposed to do any complex data analysis. The results of complex computation are stored in files. The plotting scripts just need to read these files and plot their content - not much overhead is needed. In particular this implies that we do not need to import numba for plotting! And embed() from the IPython package should not be needed - this is for more complicated issues than plotting. A well readable import list is necessary so that one can easily trace back the origin of some functions. To support this import only what is needed by your script import every package/symbol only once sort the imports according to package - common packages first, your own modules last.","title":"Package imports"},{"location":"structure/#main-code","text":"We start out at the bottom of the script with the following two lines: if __name__ == \"__main__\": s = plot_style() The call of the plot_style() function sets up the plot appearance and returns a namespace containing various plotting styles as dicussed above. The following lines of code should set up the figure, call functions generating the actual plots, and save the figure to a file. In case of our simple example this looks like this: fig, ax = plt.subplots(figsize=(6, 4)) fig.subplots_adjust(top=0.95, bottom=0.1, left=0.1, right=0.95) plot_data(ax, s) fig.savefig('basicdata.pdf') The call to plt.subplots() returns a new figure fig of the specified size and a single axes ax . Most certainly you need to adjust the figure margins via fig.subplots_adjust() . A good plot does not have excessive white space on the borders. In particular if you include your figure in a LaTeX document it is much simpler to handle when it tightly fills the figure canvas. fig.tight_layout() usually does not work, but you may give a try to the constrained_layout argument to plt.subplots() . A problem with fig.subplots_adjust() is, that the figure margins are specified relative to the figure size. Whenever changing the figure size you need to readjust the figure margins. The following function call to plot_data(ax) does the actual plotting. We discuss this in the next section. Finally, the figure needs to be saved. The filename should be the same as the name of the script to allow others to find the script given the figure file. You may omit the file extension if you have set the rcParam savefig.format to your preferred format. In the context of scientific publications this should be a vector graphic format like pdf or svg . Of course, you may stuff all this figure code into a function.","title":"Main code"},{"location":"structure/#plot-code","text":"The basic unit of any figure is a plot, a single matplotlib axes. You may rearrange the position of an axes within a figure or even move an axes to another figure. To allow for this flexibility, collecting all code needed to draw the content of an axes into a single dedicated function is central. This function takes as the first argument the axes into which it should draw. As a second argument it takes the namespace with the plotting styles. For every axes make a function that does the plotting and that takes this axes as an argument. In our example this is the plot_data() function that might look like this: def plot_data(ax, s): x, y = load_data() ax.plot(x, y, **lsSmall) ax.set_xlabel('x') ax.set_ylabel('y') The first part of the function loads or generates the data to be plotted - symbolized by the load_data() function call. The second part does the actual plotting. If you manage to separate content from design well, then the functions for the actual plotting are usually simple and sweet. Everybody can comprehend what is going on. The function - the plot - can be easily reused in a different context. Alternatively we could have called load_data() outside the plot_data() function and pass the loaded data as arguments to the plot function: x, y = load_data() plot_data(ax, s, x, y) Then plot_data() would only contain plot commands. This is in particular useful for a multi-panel plot, where many panels use the same data for their plotting. On the other hand, in many cases the data are loaded or generated in no time. So from a performance point of view it does not hurt to load/generate them for any plot within each plot function. But with the load function inside you need less function arguments and the plot function can be more easily moved somewhere else.","title":"Plot code"},{"location":"structure/#complexitysimplicity-of-the-plot-function","text":"Most of the design of the plots is handled by the central plot_style() function as described above. Then the plot function anly needs to provide content and usually gets quite simple. What is left to specify simply is: what to plot, e.g. ax.plot(x, y) . Of course, this might require several plot commands , but if you provide the data such that they can be more or less directly passed to the plot commands, this stays simple. how to annotate, e.g. ax.text() , ax.annotate() and/or some arrows. axis limits, e.g. ax.set_xlim() . tick marks (actually that often is a matter of design and should not be here...). axis scaling, e.g. ax.set_xscale('log') . axis labels, e.g. ax.set_xlabel() . That's it. No hiding of spines, no fixing of tick positions, etc. All these design issues should at least be bundled in some helper functions that would go into the central plotstyle.py module. Having code for the design directly in the plot function makes it very tedious to change the design later on, because this then needs to be changed in every plot function. Anyways, repeating the same commands over and over in all the different plot functions is not considered good coding style! Why should it be different for coding your figures? How to provide the data for the plotting function is the only other issue. You should make sure by means of other scripts that the data are available in appropriate formats. The data should be stored in a way that makes it simple to plot them. Then it is simply a matter of loading a file and selecting, for example, the relevant rows and columns. No rearranging, fixing, or whatever annoying stuff should be needed to make the data plotable. All this should go into scripts that output the files on which the plotting is based. The big advantages of keeping the plotting- as well as the data-handling code simple are less arguments need to be passed to the plot function, which makes the code less cluttered, and dependencies of the plot function are reduced, which makes it simpler to copy (or import) the plot function to another script and use it there.","title":"Complexity/simplicity of the plot function"},{"location":"structure/#multipanel-figures","text":"Scripts for multipanel figures follow the same structure as the single-panel script discussed so far. We have the same minimal imports. The main code setting up the figure is more complex, of course. For example, the main code in a coolresult.py script might look like this: if __name__ == \"__main__\": plot_style() fig, axs = plt.subplots(2, 2, figsize=(6, 4)) fig.subplots_adjust(top=0.95, bottom=0.1, left=0.1, right=0.95, hspace=0.6, wspace=0.6) plot_waveform(axs[0,0]) plot_temperature(axs[0,1]) plot_signal_n_power(axs[1,0], axs[1,1]) fig.savefig('coolresult.pdf') With the plt.subplots() we generate an array of axes. We pass hspace and wspace arguments to fig.subplots_adjust() . Try large values! You will be surprised how much better your plot looks with lot's of white space between the panels, althought the panels get smaller.","title":"Multipanel figures"},{"location":"subplots/","text":"Subplots module Enhanced subplots with margins. Importing the subplots module modifies the matplotlib functions plt.subplots() , fig.add_gridspec() , gridspec.update() . import matplotlib.pyplot as plt import plottools.subplots Then the following features are available: Figure margins In matplotlib margins, i.e. the space between the axes and the figure edges, are controlled via left , right , top , and bottom arguments to the fig.subplots_adjust() and related functions. These arguments are given in fractions of the figure size as values ranging between 0 and 1. This is often quite cumbersome, because the margins get bigger if the figure size is enlarged, although the size of the tick and axis labels stay the same. The subplots module introduces leftm , rightm , topm , and bottomm as additional arguments to the plt.subplots() , fig.subplots_adjust() , fig.add_gridspec() and gridspec.update() functions. These arguments specify the margins in units of the current font size, because the font size is what sets the size of the tick and axis labels. And they are measured from the respective figure edge, not from the figure's origin. I.e. specifying topm=0 is the same as top=1 , and results in no margin at the top of the upper axes. In addition, a resize event handler is installed, that ensures that the margins stay the same (when specified by the new arguments) when you resize the figure on the screen. TODO: image illustrating figure margins. Grid specs plt.subplots() can be called with width_ratios and height_ratios . Further, figure.add_gridspec() is made available for older matplotlib versions that do not have this function yet. To merge several subplots into a single axes, call fig.merge() .","title":"Subplots"},{"location":"subplots/#subplots-module","text":"Enhanced subplots with margins. Importing the subplots module modifies the matplotlib functions plt.subplots() , fig.add_gridspec() , gridspec.update() . import matplotlib.pyplot as plt import plottools.subplots Then the following features are available:","title":"Subplots module"},{"location":"subplots/#figure-margins","text":"In matplotlib margins, i.e. the space between the axes and the figure edges, are controlled via left , right , top , and bottom arguments to the fig.subplots_adjust() and related functions. These arguments are given in fractions of the figure size as values ranging between 0 and 1. This is often quite cumbersome, because the margins get bigger if the figure size is enlarged, although the size of the tick and axis labels stay the same. The subplots module introduces leftm , rightm , topm , and bottomm as additional arguments to the plt.subplots() , fig.subplots_adjust() , fig.add_gridspec() and gridspec.update() functions. These arguments specify the margins in units of the current font size, because the font size is what sets the size of the tick and axis labels. And they are measured from the respective figure edge, not from the figure's origin. I.e. specifying topm=0 is the same as top=1 , and results in no margin at the top of the upper axes. In addition, a resize event handler is installed, that ensures that the margins stay the same (when specified by the new arguments) when you resize the figure on the screen. TODO: image illustrating figure margins.","title":"Figure margins"},{"location":"subplots/#grid-specs","text":"plt.subplots() can be called with width_ratios and height_ratios . Further, figure.add_gridspec() is made available for older matplotlib versions that do not have this function yet. To merge several subplots into a single axes, call fig.merge() .","title":"Grid specs"},{"location":"ticks/","text":"Ticks module The ticks module adds a couple of functions to matplotlib.axes.Axes as shortcuts to the locators and formatters provided by matplotlib.ticker . Here, their usage is demonstrated for the x-axis, but of course the equivalent functions for the y-axis exist as well. Simply replace xticks by yticks in the function name. import numpy as np import matplotlib.pyplot as plt import plottools.ticks fig, ax = plt.subplots() Increments ax.set_xticks_delta(0.5) Custom format ax.set_xticks_format('%04.1f') SI unit prefixes ax.set_xscale('log') ax.set_xlim(1e-6, 1e0) ax.set_xticks_prefix() Fractions ax.set_xlim(-1, 1) ax.set_xticks_fracs(4) Multiples of Pi ax.set_xlim(-np.pi, 2*np.pi) ax.set_xticks_pifracs(2) Pi in the nominator ax.set_xlim(0, 4*np.pi/3) ax.set_xticks_pifracs(3, True) Fixed locations ax.set_xticks_fixed((0, 0.3, 1)) Fixed locations and labels ax.set_xticks_fixed((0, 0.5, 1), ('a', 'b', 'c')) No tick labels ax.set_xticks_blank() You most likely want to use common_xlabels() from the axes module. No ticks at all ax.set_xticks_off()","title":"Ticks"},{"location":"ticks/#ticks-module","text":"The ticks module adds a couple of functions to matplotlib.axes.Axes as shortcuts to the locators and formatters provided by matplotlib.ticker . Here, their usage is demonstrated for the x-axis, but of course the equivalent functions for the y-axis exist as well. Simply replace xticks by yticks in the function name. import numpy as np import matplotlib.pyplot as plt import plottools.ticks fig, ax = plt.subplots()","title":"Ticks module"},{"location":"ticks/#increments","text":"ax.set_xticks_delta(0.5)","title":"Increments"},{"location":"ticks/#custom-format","text":"ax.set_xticks_format('%04.1f')","title":"Custom format"},{"location":"ticks/#si-unit-prefixes","text":"ax.set_xscale('log') ax.set_xlim(1e-6, 1e0) ax.set_xticks_prefix()","title":"SI unit prefixes"},{"location":"ticks/#fractions","text":"ax.set_xlim(-1, 1) ax.set_xticks_fracs(4)","title":"Fractions"},{"location":"ticks/#multiples-of-pi","text":"ax.set_xlim(-np.pi, 2*np.pi) ax.set_xticks_pifracs(2)","title":"Multiples of Pi"},{"location":"ticks/#pi-in-the-nominator","text":"ax.set_xlim(0, 4*np.pi/3) ax.set_xticks_pifracs(3, True)","title":"Pi in the nominator"},{"location":"ticks/#fixed-locations","text":"ax.set_xticks_fixed((0, 0.3, 1))","title":"Fixed locations"},{"location":"ticks/#fixed-locations-and-labels","text":"ax.set_xticks_fixed((0, 0.5, 1), ('a', 'b', 'c'))","title":"Fixed locations and labels"},{"location":"ticks/#no-tick-labels","text":"ax.set_xticks_blank() You most likely want to use common_xlabels() from the axes module.","title":"No tick labels"},{"location":"ticks/#no-ticks-at-all","text":"ax.set_xticks_off()","title":"No ticks at all"}]}